<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Deep Residual Learning for Image Recognition</title>
      <link href="2020/06/17/resnet/"/>
      <url>2020/06/17/resnet/</url>
      
        <content type="html"><![CDATA[<h1><span id="deep-residual-learning-for-image-recognition">Deep Residual Learning for Image Recognition</span><a href="#deep-residual-learning-for-image-recognition" class="header-anchor">#</a></h1><div class="toc"><!-- toc --><ul><li><a href="#1-introduction-fang-fa-gai-shu">1. Introduction（方法概述）</a><ul><li><a href="#1-1-ti-chu">1.1 提出</a></li><li><a href="#1-2-xiao-guo">1.2 效果</a></li></ul></li><li><a href="#2-xiang-guan-gong-zuo-he-ta-ren-de-dui-bi">2. 相关工作（和他人的对比）</a><ul><li><a href="#2-1-can-chai-biao-shi">2.1 残差表示</a></li><li><a href="#2-2-shortcut-lian-jie">2.2 Shortcut连接</a></li></ul></li><li><a href="#3-deep-residual-learning">3. Deep Residual Learning</a><ul><li><a href="#3-1-deep-residual-learning">3.1 Deep Residual Learning</a></li><li><a href="#3-2-identity-mapping-by-shortcuts">3.2 Identity Mapping by Shortcuts</a></li><li><a href="#3-3-network-architectures"><strong>3.3 Network Architectures</strong></a></li><li><a href="#3-4-implementation"><strong>3.4 Implementation</strong></a></li></ul></li><li><a href="#4-shi-yan-jie-guo">4. 实验结果</a><ul><li><a href="#4-1-imagenet-classification"><strong>4.1 ImageNet Classification</strong></a></li></ul></li></ul><!-- tocstop --><span id="more"></span><p><strong>新的问题</strong>：当深层网络能够收敛时，<strong>退化</strong>问题（degradation problem）又出现了，即随着网络深度的增加，准确率达到饱和（不足为奇）然后迅速退化。意外的是，这种退化<strong>并不是由过拟合造成的</strong>（过拟合是训练集上好，测试集上不好，这里是训练集上也不好）。如图1所示。</p><p><img src="/2020/06/17/resnet/1.png" style="zoom:67%;"></p><blockquote><p>Fig.1 20层和56层的“plain”网络在CIFAR-10上的训练错误率（左）和测试错误率（右）。越深的网络在训练和测试上都具有越高的错误率。</p></blockquote><p><strong>提出</strong>：a residual learning framework （一个残差学习框架），能够简化使那些非常深的网络的训练，该框架使得层能<strong>根据其输入</strong>来学习残差函数（ residual functions）而非原始函数（unreferenced functions）。</p><h2><span id="1-introduction-fang-fa-gai-shu">1. Introduction（方法概述）</span><a href="#1-introduction-fang-fa-gai-shu" class="header-anchor">#</a></h2><p>训练准确率<strong>退化</strong>（degradation (of training accuracy)）的出现表明了并非所有的系统都是很容易优化的。</p><p><strong>讨论1</strong>：比较一个浅层的框架和它的深层版本。对于更深的模型，这有一种通过构建的解决方案：<strong>恒等映射</strong>（identity mapping）来构建增加的层，而其它层直接从浅层模型中复制而来。这个构建的解决方案表明了，一个更深的模型不应当产生比它的浅层版本更高的训练错误率。实验表明，我们目前无法找到一个与这种构建的解决方案相当或者更好的方案（或者说无法在可行的时间内实现）。</p><h3><span id="1-1-ti-chu">1.1 提出</span><a href="#1-1-ti-chu" class="header-anchor">#</a></h3><p><strong>提出</strong>：一种<strong>深度残差学习</strong>框架（ a deep residual learning framework）来解决这个退化问题</p><ul><li>明确的让这些层来拟合<strong>残差映射</strong>（residual mapping），而不是让每一个堆叠的层直接来拟合所需的底层映射（desired underlying mapping）</li><li>假设所需的底层映射为 $H(x)$，我们<strong>让堆叠的非线性层来拟合另一个映射</strong>： $F(x)=H(x)−x$。 因此原来的映射转化为： $F(x)+x$。我们推断残差映射比原始映射（unreferenced mapping）更容易优化。</li><li>公式 $F(x)+x$ 可以通过前馈神经网络的 “<strong>shortcut连接</strong>” 来实现(Fig.2)。（<u>shortcut 连接</u>：就是跳过一个或者多个层。）在我们的例子中，<strong>shortcut 连接只是简单的执行恒等映射，再将它们的输出和堆叠层的输出叠加在一起</strong>(Fig.2)。<strong>恒等的 shortcut 连接并不增加额外的参数和计算复杂度</strong>。完整的网络仍然能通过端到端的SGD反向传播进行训练，并且能够简单的通过公共库来实现。</li></ul><p><img src="/2020/06/17/resnet/2.png" style="zoom:67%;"></p><blockquote><p>Fig.2 残差学习：一个构建块。</p></blockquote><h3><span id="1-2-xiao-guo">1.2 效果</span><a href="#1-2-xiao-guo" class="header-anchor">#</a></h3><p>在ImageNet数据集上进行了综合性的实验来展示这个退化问题并评估了提出的方法。</p><ul><li>1) 我们极深的残差网络是很容易优化的，但是对应的“plain”网络（仅进行层的堆叠的网络）在深度增加时却出现了更高的错误率。</li><li>2) 我们的 deep residual 网络能够轻易的增加层数来提高准确率，并且结果也大大优于以前的网络。</li><li>3) 有非常好的泛化性能，CIFAR-10数据集上也出现了类似的现象，这表明了我们提出的方法的优化难度和效果并不仅仅是对于一个特定数据集而言的。</li></ul><h2><span id="2-xiang-guan-gong-zuo-he-ta-ren-de-dui-bi">2. 相关工作（和他人的对比）</span><a href="#2-xiang-guan-gong-zuo-he-ta-ren-de-dui-bi" class="header-anchor">#</a></h2><h3><span id="2-1-can-chai-biao-shi">2.1 残差表示</span><a href="#2-1-can-chai-biao-shi" class="header-anchor">#</a></h3><ul><li>对于向量量化，<strong>残差向量编码</strong>比原始向量编码更加有效。</li><li>……</li></ul><h3><span id="2-2-shortcut-lian-jie">2.2 Shortcut连接</span><a href="#2-2-shortcut-lian-jie" class="header-anchor">#</a></h3><p>shortcut 连接已经经过了很长的一段实践和理论研究过程。</p><ul><li>训练多层感知器（MLPs）的一个早期实践就是添加一个连接输入和输出的线性层。</li><li>在<a href="https://arxiv.org/abs/1409.4842">Szegedy2015Going</a> 及 <a href="https://arxiv.org/abs/1409.5185">Lee2015deeply</a>中，将一些中间层直接与辅助分类器相连接可以解决梯度消失/爆炸问题。</li><li>在 <a href="https://arxiv.org/abs/1409.4842">Szegedy2015Going</a> 中，一个“<strong>inception</strong>”层由一个 shortcut 分支和一些更深的分支组合而成。</li><li>与此同时，“<strong>highway networks</strong>”将 <strong>shortcut连接</strong> 与门控函数（gating functions）结合起来。这些门（gates）是数据相关并且是有额外参数的，而我们的恒等 shortcuts是<strong>无参数</strong>的。当一个门的 shortcut 是“closed”（接近于0）时，highway网络中的层表示非残差函数。相反的，我们的模型总是学习残差函数；我们的恒等 shortcuts 从不关闭，在学习额外的残差函数时，所有的信息总是通过的。此外，highway网络并不能由增加层的深度（例如， 超过100层）来提高准确率。</li></ul><h2><span id="3-deep-residual-learning">3. Deep Residual Learning</span><a href="#3-deep-residual-learning" class="header-anchor">#</a></h2><h3><span id="3-1-deep-residual-learning">3.1 Deep Residual Learning</span><a href="#3-1-deep-residual-learning" class="header-anchor">#</a></h3><ol><li>我们将 $H(x)$ 看作一个由部分堆叠的层（并不一定是全部的网络）来拟合的底层映射（underlying mapping），其中 $x$ 是这些层的输入。</li><li>假设多个非线性层能够逼近复杂的函数，这就等价于这些层能够逼近复杂的残差函数，例如，$H(x)−x$（假设输入和输出的维度相同）。</li><li>所以我们明确的让这些层来估计一个残差函数：$F(x)=H(x)−x$ 而不是 $H(x)$ 。因此原始函数变成了：$F(x)+x$ 。尽管这两个形式应该都能够逼近所需的函数（正如假设），但是学习的难易程度并不相同。</li></ol><p>这个重新表达的动机是由退化问题这个反常的现象(Fig.1，左)。正如我们在introduction中讨论的，如果增加的层能以恒等映射来构建，一个更深模型的训练错误率不应该比它对应的浅层模型的更大。<strong>退化问题表明了，求解器在通过多个非线性层来估计恒等映射上可能是存在困难的</strong>。而伴随着残差学习的重新表达，如果恒等映射是最优的，那么求解器驱使多个非线性层的权重趋向于零来逼近恒等映射。</p><h3><span id="3-2-identity-mapping-by-shortcuts">3.2 Identity Mapping by Shortcuts</span><a href="#3-2-identity-mapping-by-shortcuts" class="header-anchor">#</a></h3><p>我们在堆叠层上采样残差学习算法。一个构建块如 Fig.2 所示。本文中的构建块定义如下（Eq.1）：</p><p><img src="/2020/06/17/resnet/2.png" style="zoom:67%;"></p><script type="math/tex; mode=display">y = F(x, \{W_i\})+x</script><blockquote><ul><li>其中 $x$ 和 $y$ 分别表示层的输入和输出。</li><li>函数 $F(x, \{W_i\})$ 代表学到的残差映射（residual mapping ）。Fig.2 中的例子包含两层，$F = W_2 σ(W_1 x)$ ，其中$σ$ 代表 ReLU，为了简化省略了偏置项。</li><li>$F+x$ 操作由一个shortcut 连接和元素级（element-wise）加法来表示。</li><li>在加法之后，再执行一个非线性操作（例如，$σ(y)$，如Fig.2） </li></ul></blockquote><ol><li><p>Eq.1中的 <strong>shortcut连接没有增加额外的参数和计算复杂度</strong>。这不仅是一个很有吸引力的做法，同时在对”plain”网络和残差网络进行比较时也是非常重要的。可以在参数、深度、宽度以及计算成本都相同的基础上对两个网络进行公平的比较（除了可以忽略不计的元素级的加法）。</p></li><li><p>在Eq.1中<strong>，$x$ 和 $F$ 的维度必须相同</strong>。如果不相同（例如, 当改变了输入/输出的通道），我们可以通过shortcut<strong>连接执行一个线性映射 $W_s$ 来匹配两者的维度</strong>（Eq.2）（将 $x$ 变换为和 $F$ 相同维度）：</p><script type="math/tex; mode=display">y=F(x,\{W_i\})+W_sx</script></li><li><p>在Eq.1中同样可以使用方阵 $W_s$。但我们的实验表明，恒等映射（identity mapping）已足够解决退化问题（degradation problem ），并且是经济的，因此 <strong>$W_s$ 只是用来解决维度不匹配的问题</strong>。</p></li><li><p><strong>残差函数 $F$ 的形式是灵活可变的。</strong>本文实验中涉及到的函数 $F$ 是两层或者三层的（可以好几层）（Fig.5），当然更多层也是可行的。但是如果 $F$ 只含有一层，Eq.1就和线性函数：$y=W_1x+x$ 一致，因此并不具有任何优势。</p></li></ol><p><img src="/2020/06/17/resnet/3.png" style="zoom:80%;"></p><h3><span id="3-3-network-architectures"><strong>3.3 Network Architectures</strong></span><a href="#3-3-network-architectures" class="header-anchor">#</a></h3><p>我们在多个 plain 网络和残差网络上进行了测试，并都观测到了一致的现象。接下来将在ImageNet上对两个模型进行讨论。</p><p><img src="/2020/06/17/resnet/4.png" alt></p><blockquote><p>Fig.3 对应于ImageNet的网络框架举例。 <strong>左</strong>：VGG-19模型 （196亿个FLOPs）作为参考。<strong>中</strong>：plain网络，含有34个参数层（36 亿个FLOPs）。<strong>右</strong>：残差网络，含有34个参数层（36亿个FLOPs）。虚线表示的shortcuts增加了维度。<strong>Table 1</strong>展示了更多细节和其它变体。</p></blockquote><p><strong>Plain网络</strong></p><p>我们的plain网络结构（Fig.3，中）主要受 VGG网络（Fig.3，左）的启发。<br>卷积层主要为3*3的滤波器，并遵循以下两点要求：</p><ul><li>(i) 输出特征尺寸相同的层含有相同数量的滤波器；</li><li>(ii) 如果特征尺寸减半，则滤波器的数量增加一倍来保证每层的时间复杂度相同。我们直接通过stride 为2的卷积层来进行下采样。在网络的最后是一个全局的 average pooling 层和一个1000 类的包含softmax 的全连接层。加权层的层数为34，如Fig.3(中)所示。</li></ul><p>值得注意的是，我们的模型比VGG网络（Fig.3，左）有更少的滤波器和更低的计算复杂度。我们34层的结构含有36亿个FLOPs（乘-加），而这仅仅只有VGG-19 （196亿个FLOPs）的<strong>18%。</strong></p><p><strong>残差网络 Residual Network</strong></p><p>在以上plain网络的基础上，我们插入shortcut连接(Fig.3，右)，将网络变成了对应的残差版本。</p><ul><li><p>如果输入和输出的维度相同时，可以直接使用<strong>恒等shortcuts</strong> (Eq.1)（Fig.3中的实线部分）。</p></li><li><p>当维度增加时（Fig.3中的虚线部分），考虑两个选项，对于这两个选项，当shortcut跨越两种尺寸的特征图时，均使用stride为2的卷积。</p><ul><li>(A) shortcut仍然使用恒等映射，在增加的维度上使用 0 来填充，这样做不会增加额外的参数</li><li>(B) 使用Eq.2的映射shortcut来使维度保持一致（通过1*1的卷积）。</li></ul></li></ul><p><img src="/2020/06/17/resnet/5.png" alt></p><p>Table 1 对应于ImageNet的结构框架。括号中为构建块的参数(同样见Fig.5)，数个构建块进行堆叠。下采样由stride为2的conv3_1、conv4_1和conv5_1 来实现。</p><h3><span id="3-4-implementation"><strong>3.4 Implementation</strong></span><a href="#3-4-implementation" class="header-anchor">#</a></h3><ul><li><p><strong>图像增强</strong>：针对ImageNet的网络，在[256,480]中对图像的短边进行随机采样（randomly sampled）来调整图像的大小，以进行比例放大（scale augmentation）。 从一张图像或者它的水平翻转（horizontal flip）图像中随机采样一个224*224的剪裁（crop），每个像素都减去均值。使用[21]中的标准颜色增强。</p></li><li><p><strong>标准化</strong>：我们在每一个卷积层之后，激活层之前均使用batch normalization（BN）【<a href="https://www.cnblogs.com/guoyaohua/p/8724433.html】。">https://www.cnblogs.com/guoyaohua/p/8724433.html】。</a></p></li><li><p><strong>初始化</strong>：我们根据<a href="https://www.computer.org/csdl/proceedings/iccv/2015/8391/00/8391b026-abs.html">He2014spatial</a>来初始化权值然后从零开始训练所有plain/残差网络。</p></li><li><p><strong>配置</strong>：使用的mini-batch的尺寸为256。学习率从0.1开始，每当错误率平稳时将学习率除以10，整个模型进行60∗10460∗104次迭代训练。我们将权值衰减设置为0.0001，a 动量为0.9。根据 <a href="https://arxiv.org/abs/1502.03167">Ioffe2015Batch</a>，我们并没有使用Dropout。</p></li><li><p>在测试中，为了进行比较，我们采取标准的<strong>10-crop测试</strong>。</p></li></ul><p>为了达到最佳的结果，我们使用<a href="https://arxiv.org/abs/1409.1556">Simonyan2014Very</a>及<a href="https://www.computer.org/csdl/proceedings/iccv/2015/8391/00/8391b026-abs.html">He2014spatial</a>中的全卷积形式，并在多个尺度的结果上取平均分（调整图像的大小使它的短边长度分别为{224,256,384,480,640}）。</p><hr><p><strong>【注：10-crop】</strong>1-crop和10-crop顾名思义就是进行1次和10次裁剪。举个例子输入图像是256*256的，网络训练所需图像是224×224的。1-corp是从256×256图像中间位置裁一个224 × 224的图像进行训练，而10-corp是先从中间裁一个224 × 224的图像，然后从图像左上角开始，横着数224个像素，竖着数224个像素开始裁剪，同样的方法在右上，左下，右下各裁剪一次。就得到了5张224 × 224的图像，镜像以后再做一遍，总共就有10张图片了。</p><hr><h2><span id="4-shi-yan-jie-guo">4. 实验结果</span><a href="#4-shi-yan-jie-guo" class="header-anchor">#</a></h2><hr><p>【注：Top-1错误率和Top-5错误率】</p><p>首先是TOP-5正确率，举个例子，比如你训练好了一个网络，你要用这个网络去进行图片分类任务，那我假设要分类的数目有50类，那么当我进行测试时，我输入一张图片，网络会依次输出这50个类别的概率，当所有图片测试完成后，那么：TOP-5正确率就是说，在测试图片的50个分类概率中，取前面5个最大的分类概率，正确的标签（分类）有没有在里面，就是它是不是这前5个中的一个，如果是，就是分类成功，那么他的TOP-5正确率此时等于：所有测试图片中正确标签在前五个分类概率的个数/所有的测试图片数</p><p>那么，TOP-5错误率就是正确标记的样本数不在前五个概率里面的样本数除以总的样本数</p><p>同理，TOP-1错误率就是正确标记的样本数不是最佳概率的样本数除以总的样本数</p><hr><h3><span id="4-1-imagenet-classification"><strong>4.1 ImageNet Classification</strong></span><a href="#4-1-imagenet-classification" class="header-anchor">#</a></h3><p>本文在1000类的ImageNet2012数据集上对我们的方法进行评估。训练集包含128万张图像，验证集包含5万张图像。我们在10万张测试图像上进行测试，并对<strong>top-1</strong>和<strong>top-5</strong> 的错误率进行评估。</p><p><strong>对于Plain网络</strong>：评估了18层和34层的plain网络。34层的网络如图Fig.3(中)所示。18层的结构很相似，具体细节参见Table 1。</p><ul><li>34层的Plain网络比18层的Plain网络具有更高的验证错误率，为了揭示<strong>退化问题</strong>，根据Fig.4(左)我们可以看出，在整个训练过程中34 层的网络具有更高的训练错误率。</li><li>认为这种优化上的困难不太可能是由梯度消失所造成的。因为这些plain网络的训练使用了BN，这能保证前向传递的信号是具有非零方差的。我们同样验证了在反向传递阶段的梯度由于BN而具有良好的范式，所以在前向和反向阶段的信号不会存在消失的问题。</li><li>事实上34层的plain网络仍然具有不错的准确率(Table 3)，这表明了求解器在某种程度上也是有效的。</li></ul><p><strong>对于残差网络</strong>：对18层和34层的残差网络ResNets进行评估。如Fig.3 (右)所示，ResNets的基本框架和plain网络的基本相同，除了在每一对3*3的滤波器上添加了一个shortcut连接。从Table 2和Fig.4中观测到以下三点：</p><ul><li>与plain网络相反，34层的ResNet比18层ResNet的结果更优(<strong>2.8%</strong>)。这表明了这种设置可以很好的解决退化问题，并且我们可以由增加的深度来提高准确率。</li><li>与对应的plain网络相比，34层的ResNet在top-1 错误率上降低了<strong>3.5%</strong> (Table 2)。这也验证了在极深的网络中残差学习的有效性。</li><li>18层的plain网络和残差网络的准确率很接近 (Table 2)，但是ResNet 的收敛速度要快得多。(Fig.4 右 vs 左)。如果网络“<strong>并不是特别深</strong>” (如18层)，现有的SGD能够很好的对plain网络进行求解，而ResNet能够使优化得到更快的收敛。</li></ul><p><img src="/2020/06/17/resnet/6.png" alt></p><blockquote><p> Fig.4 在<strong>ImageNet</strong>上进行训练。细曲线为训练错误率，粗曲线为使用中心crop时的验证错误率。左：18和34层的plain网络。右：18 和34层的ResNets。在这个图中，残差网络和对应的plain网络相比并没有增加额外的参数。</p></blockquote><p><img src="/2020/06/17/resnet/7.png" style="zoom:67%;"></p><blockquote><p>Table 2 ImageNet验证集上的Top-1错误率 (%, 10-crop testing)。这里的ResNets并没有额外增加的参数。Fig.4展示了整个训练过程。</p></blockquote><p><img src="/2020/06/17/resnet/8.png" style="zoom:67%;"></p><blockquote><p>Table 3 在ImageNet验证集上的错误率 (%, <strong>10-crop</strong> testing)。VGG-16是基于我们测试的网络。ResNet-50/101/152使用了选项B——利用映射来匹配增加的维度。</p></blockquote><p><img src="/2020/06/17/resnet/9.png" style="zoom:67%;"></p><blockquote><p>Table 4 <strong>单一模型</strong>在ImageNet验证集上的错误率(%)(除了 ++ 是在验证集上的结果)。</p></blockquote><p><img src="/2020/06/17/resnet/10.png" style="zoom:67%;"></p><blockquote><p>Table 5 <strong>组合模型</strong>在ImageNet测试集上的top-5错误率。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> paper-cv </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Very Deep Convolutional Networks for Large-Scale Image Recognition</title>
      <link href="2020/06/16/vgg/"/>
      <url>2020/06/16/vgg/</url>
      
        <content type="html"><![CDATA[<h1><span id="very-deep-convolutional-networks-for-large-scale-image-recognition">Very Deep Convolutional Networks for Large-Scale Image Recognition</span><a href="#very-deep-convolutional-networks-for-large-scale-image-recognition" class="header-anchor">#</a></h1><div class="toc"><!-- toc --><ul><li><a href="#1-introduction">1. INTRODUCTION</a></li><li><a href="#2-convnet-pei-zhi">2. ConvNet 配置</a><ul><li><a href="#2-1-jia-gou">2.1 架构</a></li><li><a href="#pei-zhi">配置</a></li><li><a href="#2-3-tao-lun">2.3 讨论</a></li></ul></li><li><a href="#3-fen-lei-kuang-jia">3 分类框架</a><ul><li><a href="#3-1-training">3.1 Training</a></li><li><a href="#3-2-testing">3.2 Testing</a></li></ul></li><li><a href="#4-classification-shi-yan">4. classification 实验</a><ul><li><a href="#4-1-tu-xiang-dan-chi-du-ping-gu">4.1 （图像）单尺度评估</a></li><li><a href="#4-2-duo-chi-du-ping-gu-multi-scale">4.2 多尺度评估 multi-scale</a></li><li><a href="#4-3-duo-cai-qie-tu-xiang-ping-gu-muti-crop">4.3 多裁切图像评估 muti-crop</a></li><li><a href="#4-4-juan-ji-wang-luo-rong-he-convnet-fusion">4.4 卷积网络融合 Convnet Fusion</a></li></ul></li><li><a href="#5-jie-lun">5. 结论</a></li></ul><!-- tocstop --></div><p>[TOC]</p><p>论文时间：2015年</p><ul><li>研究内容：大规模图像识别任务下卷积网络深度对其预测准确率的影响</li><li>主要贡献：使用具有非常小的（3×3）卷积滤波器（convolution filters）的架构对深度不断递增的网络进行全面评估。</li></ul><p>VGG模型论文探讨并证明了以下观点：</p><ol><li>用多层的卷积层组合配以小尺寸的滤波器（3 <em> 3），能实现大尺寸滤波器的感受野的同时，还能使参数数量更少；（其他模型可能会用11</em>11，stride=4的卷积核）</li><li>加深模型深度可以获得更好的分类结果</li><li>训练期间分阶段降低学习率有助模型收敛；</li><li>在数据增强方面，训练时：随机从rescale后的图中裁出224*224的区域（如果rescale后的图很大，那截取到的只是图中的一部分），接下来后再水平翻转，RGB通道随机变换；测试时候，将模型的全连接改成卷积。</li></ol><span id="more"></span><h2><span id="1-introduction">1. INTRODUCTION</span><a href="#1-introduction" class="header-anchor">#</a></h2><p>本文解决了ConvNet架构设计的一个重要方面——深度。为此，固定（v）了结构中的其他参数，并通过<strong>增加更多的卷积层来稳步增加网络的深度</strong>，这是可行的，因为在所有层中都使用了<strong>非常小的（3×3）卷积滤波器（convolution filters）</strong>。</p><h2><span id="2-convnet-pei-zhi">2. ConvNet 配置</span><a href="#2-convnet-pei-zhi" class="header-anchor">#</a></h2><p>为了衡量ConvNet深度在公平环境中所带来的改进，我们所有的ConvNet层配置都采用相同的原则设计。在本部分中，首先描述ConvNet配置的通用布局（第2.1节），然后详细说明评估中使用的具体配置（第2.2节）。 然后（第2.3节）讨论我们的设计选择，并与现有技术进行比较。</p><h3><span id="2-1-jia-gou">2.1 架构</span><a href="#2-1-jia-gou" class="header-anchor">#</a></h3><p>在训练期间，ConvNets的输入是固定尺寸的224×224 RGB图像。</p><ul><li>预处理：唯一做的预处理是从每个像素中<strong>减去在训练集上计算的RGB均值</strong>。</li><li>图像通过堆叠的卷积层，其中使用了感受野（receptive field）非常小的<strong>卷积核（filters ）：3×3</strong>（这是左/右，上/下，中心点概念可捕获的最小尺寸）。</li><li>在其中一种配置中，我们还使用1×1卷积滤波器，这可以看作是输入通道的线性变换（随后是非线性）。</li><li>卷积<strong>步长 stride</strong> 固定为1个像素；</li><li><strong>卷积层的空间填充</strong>（spatial padding）是指，使得在卷积操作后保留原空间的分辨率（resolution），比如如果使用3×3 卷积核，就填充1个像素。</li><li><strong>空间池化（Spatial pooling ）</strong>是由五个最大池化层完成的，每个池化层前面都会有若干个卷积层（并非所有的卷积层后都使用最大池化层）。 </li><li><strong>Max-pooling 最大池化</strong>是以2×2像素窗口上执行，步幅为2。</li><li>堆叠的卷积层（在不同的体系结构中具有不同的深度）之后是三个<strong>完全连接（FC）层</strong>：前两个具有4096个通道，第三个执行1000类别的ILSVRC分类，因此包含1000个通道（一个 为每个类）。</li><li>最后一层是<strong>soft-max层</strong>。 全连接层的配置在所有网络中都是相同的。</li><li><u>所有隐藏层</u>都配备了<strong>ReLU激活函数</strong>。注意到我们的网络（除了一个网络）都没有包含局部响应归一化层标准化（LRN Local Response Normalisation）。这种标准化不会提升ILSVRC数据集的性能，但会导致内存消耗和计算时间的增加。</li></ul><h3><span id="pei-zhi">配置</span><a href="#pei-zhi" class="header-anchor">#</a></h3><p>本文中评估的ConvNet配置在表1中列出，每列一个。 下面我们将以他们的名字（A-E）来提及。 </p><p>所有的配置都遵循2.1节中提到的通用设计，并且仅在深度上有所不同：从网络A中的11个权重层（weight layers）（8个卷积层和3个全连接层）到网络E中的19个权重层（weight layers）（16个卷积层和3个全连接层）。</p><p>卷积层的宽度（通道 channel 数量）相当小，从第一层的64开始，然后在每个最大池层后增加1倍，直到达到512。</p><p>在表2中，我们报告了每个配置的参数数目。 <u>尽管深度很大，但我们网络的权重数量不会超过那些深度较小、但卷积核和感受野宽度更大的网络</u>。</p><p><img src="/2020/06/16/vgg/1.png" style="zoom:67%;"></p><p>注意到在没有任何标准化层的情况下，使用局部响应标准化（ local response normalisation）（A-LRN网络）在模型A上没有改进。 因此，我们在深层架构（B-E）中不采用标准化层。</p><h3><span id="2-3-tao-lun">2.3 讨论</span><a href="#2-3-tao-lun" class="header-anchor">#</a></h3><p><strong>区别性</strong>：我们 ConvNet配置与 ILSVRC-2012以及 ILSVRC-2013的最佳模型相比有着较大差别。区别于<strong>之前的模型在首层卷积层所使用的较大的感受野</strong>（比如11x11卷积核配合步幅4（Krizhevsky et al., 2012），7x7卷积核配合步幅2（Zeiler &amp; Fergus, 2013; Sermanet et al., 2014）），<strong>我们整体都使用了非常小的3x3卷积核配合步幅1</strong>。</p><p><strong>等效性</strong>：显而易见的是，用两层的3x3卷积层组合（中间不包含池化层）所得到的感受野相当于一层的5x5卷积层的感受野；而三层这样的卷积层组合所得到的感受野相当于一层的7x7卷积核的感受野。</p><p><strong>更强的分辨力</strong>：如果我们用三层3x3的卷积层组合来代替一层7x7卷积层，我们会得到什么呢？首先，我们并入了三个ReLU激活函数，而不是一个，这使决策功能的分辨力更强。 </p><p><strong>更少的参数</strong>：其次，我们减少参数的数量：假设三层3×3卷积层相叠的输入和输出都具有C个通道，则该叠层参数化为 $3×(3^2C^2)=27C^2$ 个权重; 同时，一个7×7 卷积层需要 $7^2C^2=49C^2$  参数，参数量会增加 81％。 这<u>可以被看作是在7×7卷积中实施正规化</u>（regularisation）， <u>迫使他们通过3×3卷积核进行分解</u>（两者之间注入非线性）。</p><p><strong>1×1卷积核</strong>：纳入1×1卷积核（配置C，表1）是一种<u>增加决策函数的非线性而不影响卷积层感受野</u>的方法。 尽管在我们的例子中，1×1卷积本质上是一个线性投影到相同维度的空间上（输入和输出通道的数目是相同的），但激活函数引入了一个额外的非线性。 </p><p><strong>与其他工作的对比</strong>：</p><ol><li>大规模数据集+更深：Ciresan等人以前曾使用过小尺寸的卷积滤波器 （2011年），但他们的网络明显不如我们的深，并且他们没有对大规模ILSVRC数据集进行评估。</li><li>Goodfellow等人（2014）将深度ConvNets（11个权重层）应用于街道号识别任务，并表明增加深度能获得更好的性能。</li><li>GoogLeNet（Szegedy et al.，2014）是ILSVRC-2014分类任务中性能最好的一个入门版本，它的开发与我们的工作无关，但它的基础是非常深的ConvNets（22个加权层）和小卷积滤波器（除3×3外，还使用1×1和5×5卷积）。并且，它们的网络拓扑结构比我们的要复杂，并且在第一层更积极地降低了特征图的空间分辨率，以减少计算量。正如将在4.5节中所显示的那样，我们的模型超过了Szegedy等人的模型（2014年）的单网分类准确性。</li></ol><h2><span id="3-fen-lei-kuang-jia">3 分类框架</span><a href="#3-fen-lei-kuang-jia" class="header-anchor">#</a></h2><p>之前介绍了网络配置的细节。 在本节中，我们将介绍ConvNet训练和评估的分类细节。</p><h3><span id="3-1-training">3.1 Training</span><a href="#3-1-training" class="header-anchor">#</a></h3><p>训练是通过使用<strong>小批量梯度下降</strong>（mini-batch gradient descent）（基于反向传播）的<strong>动量优化多项逻辑回归目标</strong>（optimising the multinomial logistic regression objective with momentum）来实现的。</p><p><strong>具体配置细节：</strong></p><ul><li><p><u>批量大小（batch size）</u>设置为256，<u>动量（momentum）</u>为0.9。 训练通过<u>weight 衰减</u>（L2惩罚系数设置为 $5·10^{-4}$ ）和前两个全连接层（<u>dropout</u>设置为0.5）的dropout正则化来调整。 </p></li><li><p><u>学习率</u>最初设置为 $10^{-2}$ ，然后在验证集精度停止增长时再降低10倍。 总的来说，学习率（learning rate）一共降低了3次，并且在370K个迭代（74代）后停止了学习。 </p></li><li><p>我们推测，尽管与（Krizhevsky et al.，2012）相比，网络的参数数量更多，网络深度也更大，但能用更少的迭代次数来实现收敛，由于：（a）更大深度和更小卷积核所带来的隐式正则化；（b）某些图层的预初始化。</p></li></ul><p><strong>网络权重的初始化</strong>很重要，因为由于深度网络中的梯度不稳定，初始化不好可能会导致学习停滞。 </p><ol><li>为了避免这个问题，我们从训练配置A（表1）开始，这个网络足够浅，可以随机初始化进行训练。 </li><li>然后，当训练更深的体系结构时，我们使用了网络A的权值来初始化了前四个卷积层和最后三个完全连接的层，（中间层随机初始化）。</li><li>我们没有降低预初始化图层的学习速率，允许它们在学习期间改变。 对于随机初始化（如有），我们从具有零均值和 <img src="https://www.zhihu.com/equation?tex=10%5E%7B%E2%88%922%7D" alt="[公式]"> 方差的正态分布采样权重。 偏差初始化为零。 </li></ol><p><strong>图像缩放</strong>：</p><p>为了获得224×224固定大小的 ConvNet输入图像，他们从重新缩放的训练图像中随机裁剪（每个SGD迭代每个图像裁剪一次）。 为了进一步增强训练集，被裁剪的图像经过随机水平翻转和随机RGB颜色偏移处理（Krizhevsky et al.，2012）。 下面将介绍训练图像缩放。</p><p><strong>训练图像尺寸。</strong> 设S是等比例缩放的训练图像的最小边，ConvNet基于这些图像的裁剪作为输入（我们也称S为训练尺度）。 裁剪大小固定为224×224，但原则上S可以取不小于224的任何值：对于S = 224，裁剪图将捕获整幅图像统计数据，完全跨越训练图像的最小边; 对于S&gt;&gt;224，裁剪图将对应于图像的一小部分，包含一个小物体或一个物体部分。</p><p><strong>考虑设定训练尺度S的两种方法</strong>。</p><ol><li>第一种方法是<strong>固定S</strong>，对应于单尺度训练（single-scale training）。 在实验中，评估了以两个固定尺度训练的模型：S = 256和S = 384。给定一个ConvNet配置，我们首先使用S = 256来训练网络。为了<strong>加速</strong>S = 384网络的训练，<u>它被初始化为具有S = 256的预训练权重，并且我们使用较小的学习率初始值为 $10^{-3}$</u> 。</li><li><strong>设定S的第二种方法是多尺度训练 (multi-scale training)</strong>，其中通过从特定范围[Smin，Smax]（我们使用Smin = 256和Smax = 512）随机采样S来单独重新调整每个训练图像。 由于图像中的物体可能具有不同的大小，因此在训练时考虑到这一点是有益的。 这可以看作是通过缩放抖动(scale jittering)来<strong>增强训练集( training set augmentation)</strong>，其中单个模型被训练以识别多种类别的物体。 出于<strong>速度</strong>的原因，<u>我们通过对具有相同配置的单尺度模型的所有层进行微调来训练多尺度模型，并使用固定的S = 384进行预训练</u>。</li></ol><h3><span id="3-2-testing">3.2 Testing</span><a href="#3-2-testing" class="header-anchor">#</a></h3><p>测试时，给定一个训练有素的ConvNet和一个输入图像，它按以下方式分类。</p><ol><li>将其等比例缩放到预定义的最小边，表示为Q（我们也将其称为测试尺度）</li><li>然后，网络以类似于（Sermanet等人，2014）的方式被密集地应用在重新缩放的测试图像上。也就是说，全连接的层首先被转换成卷积层（第一个FC层转为7×7的卷积层，后两个FC层转为1×1 卷积层）。然后将所得的全卷积网络应用于整个（未裁剪的）图像。</li><li>其结果是一个类别得分映射，其类别数等于任务的目标分类数，以及一个可变的空间分辨率，取决于输入图像的大小。</li><li>最后，为了获得固定大小的图像类别分数的向量，类别得分映射会被空间平均（sum-pooled）。</li><li>我们还通过水平翻转(horizontal flipping)图像来增强测试集；对原始图像和翻转图像的softmax分类概率进行平均以获得图像的最终分数。</li></ol><p>使用大量的裁剪图像，可以提高准确性，因为与全卷积网络相比，它可以更精细地对输入图像进行采样。此外，由于卷积边界条件不同，<strong>多裁剪图像评估</strong>与<strong>密集评估</strong>是互补的：</p><ul><li>将ConvNet应用于裁剪图像时，卷积后的特征映射用零填充</li><li>而在密集评估的情况下，同一裁切图像的填充天然地来自于图像的相邻部分（由于卷积和空间池化），这大大增加了整个网络的感受野，因此捕获更多的上下文信息。</li><li>尽管我们认为在实践中增加多裁切图像(multiple crops )的计算时间并不能证明潜在的准确度增加，但我们对于每种尺寸规模（5×5个常规栅格和2种翻转）都使用50个裁切图像来评估我们的网络，总共150个裁切图像(crops)、超过3个尺度(scales)，这与Szegedy等人使用的4种尺度、144个裁切图像相当 （2014）。</li></ul><h2><span id="4-classification-shi-yan">4. classification 实验</span><a href="#4-classification-shi-yan" class="header-anchor">#</a></h2><h3><span id="4-1-tu-xiang-dan-chi-du-ping-gu">4.1 （图像）单尺度评估</span><a href="#4-1-tu-xiang-dan-chi-du-ping-gu" class="header-anchor">#</a></h3><ul><li>首先，我们注意到在没有任何标准化层的情况下，<u>使用局部响应标准化（A-LRN网络）在模型A上没有改进</u>。 因此，我们在深层架构（B-E）中不采用标准化层。</li><li>其次，我们观察到<u>分类错误随着ConvNet深度的增加而减少</u>：从模型A的11层到模型E的19层。</li><li>值得注意的是，尽管深度相同，配置C（其包含三个1×1的转换层），比整个网络全部使用3×3 卷积的配置D更差。这表明<u>虽然额外的非线性确实有帮助（C比B好），但使用感受野范围不少的卷积核（D比C好）捕获空间上下文也很重要</u>。</li><li>当深度达到19层时，<u>我们架构的错误率会饱和</u>，但即使是更深的模型也可能对更大的数据集有所帮助。</li><li>我们还特意以B网络为基准，把每两层3x3卷积替换为一层5×5 卷积核的浅网进行比较（其具有与B网络相同的感受野，见2.3节中解释）。该浅层网络的Top-1误差比B网络（用中心裁切图像）的误差高7％，这证实了<u>带有小型卷积核的深网优于具有更大卷积核的浅网</u>。</li><li>最后，即使在测试时使用单尺度图像，训练时的图像缩放（S∈[256; 512]）比起图像固定最小边（S = 256或S = 384）得到明显更好的结果。 这证实了<u>通过尺度抖动来增强训练集确实有助于捕获多尺度图像统计信息</u>。</li></ul><p><img src="/2020/06/16/vgg/2.png" style="zoom:67%;"></p><h3><span id="4-2-duo-chi-du-ping-gu-multi-scale">4.2 多尺度评估 multi-scale</span><a href="#4-2-duo-chi-du-ping-gu-multi-scale" class="header-anchor">#</a></h3><p>在评估了ConvNet模型的单一尺度后，我们现在<u>评估测试时尺度抖动的影响</u>。</p><p>包括在一个测试图像的多个缩放版本上运行模型（对应于不同的Q值），然后对结果分类的后验概率进行平均。</p><p> 考虑到训练和测试所用尺度的巨大差异会导致性能下降</p><ul><li>用固定S训练的模型在三个图像尺寸上进行测试评估，测试尺寸接近训练尺寸：Q = {S - 32，S，S + 32}。 </li><li>同时，训练时的尺度抖动可使网络在测试时使用更广泛的尺度范围，所以模型用变量 S∈[Smin, Smax] ，在更大范围的尺寸Q = {Smin，0.5(Smin + Smax)，Smax}下评估。</li></ul><p>结论：</p><ul><li>表4中所示的结果表明，<strong>在测试时的尺度抖动可得到更好的性能</strong>（与在单尺度上评估相同模型相比，如表3所示）。</li><li>与以前一样，最深的配置（D和E）表现最好，而使用缩放抖动的训练模型优于使用固定最小边S的训练模型。</li></ul><p><img src="/2020/06/16/vgg/4.png" style="zoom:67%;"></p><h3><span id="4-3-duo-cai-qie-tu-xiang-ping-gu-muti-crop">4.3 多裁切图像评估 muti-crop</span><a href="#4-3-duo-cai-qie-tu-xiang-ping-gu-muti-crop" class="header-anchor">#</a></h3><p>在表5中，我们将密集的（dense）ConvNet评估与多裁切图像（mult-crop ）评估进行比较（详情请参见3.2节）。 我们还通过softmax输出均值来评估两种评估技术的互补性。 可以看出，<u>使用多裁切图像的表现略好于密集评估，而且这两种方法确实是互补的，因为它们的组合优于其中的每一种</u>。 如上所述，我们假设这是由于对卷积边界条件的不同处理。</p><p><img src="/2020/06/16/vgg/5.png" alt></p><h3><span id="4-4-juan-ji-wang-luo-rong-he-convnet-fusion">4.4 卷积网络融合 Convnet Fusion</span><a href="#4-4-juan-ji-wang-luo-rong-he-convnet-fusion" class="header-anchor">#</a></h3><p>到目前为止，我们评估了单个ConvNet模型的性能。 在这部分实验中，我们<strong>通过模型的softmax分类后验概率均值来合并几个模型的输出</strong>。 由于模型的互补性，这提高了性能，这种方法在2012年和2013年的最优ILSVRC提交中使用过。</p><p>结果如表6所示。到ILSVRC提交时，我们只训练单尺度网络以及多尺度模型D（通过仅对完全连接层而不是所有层进行微调）。 </p><ul><li>由此产生的7个网络的融合模型具有7.3％的ILSVRC测试错误率。</li><li>提交之后，我们考虑了只有两个表现最好的多尺度模型（配置D和E）的集合，它使用密集评估将测试错误率降低到7.0％</li><li>而使用组合密集和多裁切图像评估将测试错误率则降低到6.8％。 作为参考，我们表现最佳的单模型实现了7.1％的误差（模型E，表5）。</li></ul><p><img src="/2020/06/16/vgg/6.png" alt></p><h2><span id="5-jie-lun">5. 结论</span><a href="#5-jie-lun" class="header-anchor">#</a></h2><p>在这项工作中，评估了用于大规模图像分类的深层卷积网络（多达19个权值层）。 已经证明，表示层的深度有利于分类准确性，并且通过大幅增加网络深度便可以使用传统的ConvNet架构来实现ImageNet挑战数据集上的最新性能（LeCun等，1989; Krizhevsky等， 2012）。 在附录中，我们还展示了我们的模型能很好地泛化应用于其他的任务和数据集，不亚于甚至性能优于那些深度略浅、更复杂的识别流水线。 我们的结果再一次证实了视觉表示中深度的重要性。</p>]]></content>
      
      
      <categories>
          
          <category> paper-cv </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Densely Connected Convolutional Networks</title>
      <link href="2020/06/01/dccn/"/>
      <url>2020/06/01/dccn/</url>
      
        <content type="html"><![CDATA[<h1><span id="densely-connected-convolutional-networks">Densely Connected Convolutional Networks</span><a href="#densely-connected-convolutional-networks" class="header-anchor">#</a></h1><p>时间：2018-6</p><p><strong>摘要</strong>：最近的工作表明，如果在靠近输入的层和靠近输出的层之间包含更短的连接，那么卷积网络可以显著地更深、更准确、更有效。DenseNet 根据这一观察结果，将每一层以前馈的方式连接到其余的每一层。传统的具有 $L$ 层的卷积网络有 $L$ 个连接（每层与其后续层之间有一个），我们的网络拥有 $L(L+1)/2$ 个直连接（$ C_{L}^{2}$）。对于每一层，使用前面所有层的特征图作为输入，它自己的特征图作为所有后续层的输入。</p><p>DenseNet 有以下几个<strong>优点</strong>：</p><ol><li>减轻了梯度消失带来的问题</li><li>增强了特征的传播</li><li>鼓励特征重用</li><li>大大减少了参数量</li></ol><div class="toc"><!-- toc --><ul><li><a href="#yin-yan">引言</a></li><li><a href="#xiang-guan-gong-zuo">相关工作</a></li><li><a href="#densenets">DenseNets</a></li><li><a href="#shi-yan">实验</a></li><li><a href="#tao-lun">讨论</a><ul><li><a href="#model-compactness-mo-xing-jin-cou-xing">Model compactness 模型紧凑型</a></li><li><a href="#implicit-deep-supervision-yin-shi-shen-du-jian-du">Implicit Deep Supervision 隐式深度监督</a></li><li><a href="#stochastic-vs-deterministic-connection">Stochastic vs. deterministic connection</a></li></ul></li></ul><!-- tocstop --></div><p>[TOC]</p><span id="more"></span><p>源码：<a href="https://www.cnblogs.com/yjphhw/p/10034265.html">https://www.cnblogs.com/yjphhw/p/10034265.html</a></p><p><a href="https://gitee.com/sxjhello/vision/blob/master/torchvision/models/densenet.py">https://gitee.com/sxjhello/vision/blob/master/torchvision/models/densenet.py</a></p><h2><span id="yin-yan">引言</span><a href="#yin-yan" class="header-anchor">#</a></h2><p>各种CNN已经成为了视觉对象识别的主流机器学习方法。虽然它们最初是在20多年前引入，但直到最近才得到更近一步的发展。最初的LeNet5 包含5层，VGG 有19 层，直到 Highway Networks 和  Residual Networks（ResNets）的出现，才达到了100层之上。</p><p>随着 CNN 变得越来越深，梯度消失问题出现了：当关于输入或梯度的信息传递了很多层之后，当它到达网络的末端（或开始）时，它可能消失。 </p><p>因为<strong>梯度消失</strong>的问题，提出了许多解决办法。<u>Highway Net</u> 和 <u>ResNet</u> 通过身份连接（identity connections）将信号从一层传到下一层。<u>Stochastic depth</u> 通过随机丢弃 ResNet 在训练期间的层来获得更好的信息和梯度流。 <u>FractalNets</u> 重复组合具有不同卷积块数量的几个平行层序列，以获得较大的深度，同时在网络中保持许多 short paths。虽然不同的方法各不相同，但它们有一个共同的特征：<strong>它们均创建了从 early layers 到 later layers 的 short paths.</strong></p><p>在这篇论文中，提出了一种将这种特性提炼为简单的连接模式的架构：来确保网络各层之间最大的信息流，<strong>将所有层（具有同样大小的匹配的特征图）彼此进行直接连接</strong>。</p><p>为了保持这种前馈特性，每一层要从之前所有层中获得额外的输入，并将自身的特征图传到后续所有层中，如图1：</p><p><img src="/2020/06/01/dccn/1.png" style="zoom:80%;"></p><p>值得注意的是：和 ResNet 相比，这里没有通过将特征求和的组合方式传到一个图层中，相反，这里采用了连接的组合方式。</p><p>因此，第 $l$ 层有 $l$ 个输入（从0开始编号），这些输入是由第 $l$ 层之前的所有卷积块的特征图组成，它自己的特征图传向了其后的  $L-l$ 个后续层。这就引入了  $L$ 层网络的  $\frac{L(L+1)}{2}$ 个连接，而不是传统的 $L$ 个连接。</p><p>因为这种<strong>密集连接的模式</strong>（dense connectivity pattern），所以顾名思义，得到了 Dense Convolutional Network (DenseNet)。</p><p>注：这种密集连接的模式的一个可能与直觉相反的效果是，<strong>它需要比传统卷积网络更少的参数</strong>，因为它不需要重新学习冗余的特征图。<u>传统的前馈结构</u>可以看作一种状态算法，这种状态从一层传递到下一层，每一层从它的前一层读取状态，并写入后面的层。虽然这种方式改变了状态，但是传递了需要保留的信息。</p><p>ResNet 通过 additive identity transformations 达到了使信息显式保持的目的。ResNet的最新变体[13]表明，许多层的贡献很小，实际上可以在训练期间随机丢弃。ResNet的参数量大很多，因为每一层都有自己的权重。</p><p>而这里提出的 DenseNet 结构将添加到网络上的信息和需要保留的信息进行了明确的区分，<strong>DenseNet 的各层都非常窄</strong>（比如，每层只有12个 filter），仅向网络的  “collective knowledge（集体知识）”  中添加一小部分特征图，并保持其余的特征图不变，最终的分类器基于网络中所有的特征图进行决策。</p><p>DenseNet 的另外一大优点是它们<strong>改善了整个网络中的信息流和梯度流</strong>，这使得它们更容易训练。每一层都能直接从损失函数和原始输入信号中获得梯度，这有助于<strong>训练更深层次的网络架构</strong>。此外，还发现密集连接有一种<strong>正则化（regularization）的效果</strong>，这减小了在小规模训练集上的任务的过拟合问题。</p><p><strong>summary：</strong></p><ol><li>需要更少的参数量</li><li>有助于训练更深的网络架构</li><li>正则化效果，解决过拟合问题</li></ol><p>【注：<u>一些 benchmark datasets</u>：CIFAR-10，CIFAR-100，SVHN，ImageNet】</p><h2><span id="xiang-guan-gong-zuo">相关工作</span><a href="#xiang-guan-gong-zuo" class="header-anchor">#</a></h2><p><u>Highway Net</u> 是首批提供一种有效地训练超过100层的端到端的网络体系结构之一。Highway Net 使用了 bypassing paths along with gating units，可以毫不费力的优化上百层。<strong>The bypassing paths</strong> 是可以更加容易地训练非常深的网络的关键。<u>ResNets</u> 就是进一步支持了这一点，在 ResNets 中，使用了  pure identity mappings 来作为 The bypassing paths。</p><p>而且， <strong>stochastic depth</strong> 通过在训练期间随机丢弃 layers，成功训练了 1202 层的 ResNet。这表明并非所有层都是必需的，并表明 <strong>deep (residual) networks 中存在大量冗余</strong>。DenseNet 便是在一定程度上受了该 observation 的启发。</p><p>一种使网络更深（例如，借助 skip connections）的正交化方法是<strong>增加网络的宽度</strong>，GoogleNet 就是这种。GoogleNet 使用 “Inception module” 将由不同大小的 filter 生成的特征图连接在一起。事实上，简单地增加 ResNets 各层 filter 的数量，就可以在足够深的网络中提升其性能。 <u>FractalNets</u> 使用这样的 wide network structure 也取得了不错的结果。</p><p>DenseNet 没有采用极深的或极宽的结构进行代表性的特征抽取，而是通过<strong>特征复用</strong>来发掘网络的潜能，生成易于训练和参数高效化的精简模型。连接不同层学习的特征图可以增加后续层的输入的变化并提高效率，这就是 <strong>DenseNet 和 ResNet 的主要区别</strong>。和将来自不同层的特征连接到一起的 Inception networks 相比，DenseNets 更加简洁高效。</p><h2><span id="densenets">DenseNets</span><a href="#densenets" class="header-anchor">#</a></h2><p>考虑一张通过卷积网络的图片 $x_0$ ，该网络包含 $L$ 层，每个层实现一个非线性转换 $H_l(·)$ ，其中 $l$ 表示层的编号，$H(·)$ 可以是诸如 Batch Normalization(BN)、rectified linear units (ReLU)、Pooling 或者 Convolution (Conv) 等操作的复合函数。我们将第 $l$ 层的输出定义为 $x_l$ </p><ol><li><p><strong>ResNet</strong>：</p><ul><li>传统的前馈卷积网络，将第 $l$ 层的输出作为输入连接到第 $l+1$ 层，产生以下转换： $x_l = H_l(x_{l-1})$ ；</li><li>ResNet 增加了一个<strong>跨层连接（skip-connection）</strong>，它使用 <strong>identity function</strong> （恒等函数）绕过了非线性变换：$x_l = H_l(x_{l-1})+x_{l-1}$ 。</li><li>ResNet 的一个优点是梯度可以直接通过 identity function 从后面的层流到较前面的层。但是， identity function （恒等函数）和输出是通过求和的方式连接到一起，可能会阻碍网络中的信息流。</li></ul></li><li><p><strong>Dense connectivity：</strong></p><ul><li><p>为了进一步改善各层间的信息流，这里提出了一个不同的连接模式：提出了从任何层向其所有后续层的直连接，如图1所示。</p></li><li><p>因此，第 $l$  层接受其前所有层的特征图作为输入：$x_l = H_l([x_0,x_1,…,x_{l-1}])$ </p></li><li><p>其中 $[x_0, x_1,…,x_l-1]$ 表示第 $0$ 到 $l-1$ 层产生的特征图的连接。</p></li><li><p>为了便于应用，我们将上式中的多输入 $[x_0, x_1,…,x_l-1]$ 连接成一个张量（ a single tensor）。</p><p><img src="/2020/06/01/dccn/1.png" style="zoom: 67%;"></p></li></ul></li><li><p><strong>Composite function</strong>：</p><ul><li>将 $H_l(·)$ 定义为一个复合函数，它有三部分连续的操作组成：<strong>Batch Normalization、ReLU 和一个3x3的卷积操作</strong>。</li></ul></li><li><p><strong>Pooling layers：</strong></p><ul><li>当特征图的尺寸发生变化时，$x_l = H_l([x_0,x_1,…,x_{l-1}])$  中的连接操作是不可行的。然而，卷积网络的一个重要组成部分就是下采样层，它可以改变特征图的尺寸。</li><li>为了便于在我们的网络结构中使用下采样层（down-sampling layers），我们将网络划分为多个紧密相连的<strong>密集块（dense blocks）</strong>，如图2所示。</li><li>我们将块之间的层称为<strong>过渡层（transition layers）</strong>，它们进行卷积和池化操作。</li><li>本文实验中使用的过渡层包括一个 BN 层和一个 1x1 的卷积层，其次是一个 2x2 的平均池化层。</li></ul><p><img src="/2020/06/01/dccn/2.png" style="zoom:150%;"></p><p><em>图2 ：一个拥有三个稠密块的 DenseNet 网络，两个相邻块之间的层称为过渡层，通过卷积和池化来改变特征图的大小。</em></p></li><li><p><strong>Growth rate：</strong></p><ul><li>如果每个函数 $H_l$ 产生 $k$ 个特征图，那么第 $l$ 层的输入特征图总数为：$k_0 + k × (l-1)$ ，$k_0$ 代表输入层的  channels 数量。（就是每一层的输出是 k 个特征图，前面有 $l-1$ 层，然后再把原始输入层的 $k_0$ 个输入加上）</li><li>DenseNet和现有网络结构的一个重要区别在于DenseNet具有很窄的层，例如 k=12 ，我们把<strong>超参数 <code>k</code> 称为网络的增长率（growth rate）</strong>。我们的实验表明一个较小的增长率就可以获得相对好的效果。</li><li>一种解释就是，网络的各块中的每一层都可以获得该块内其前的所有特征图，因此，可以访问网络的集体知识（“collective knowledge”）。每一层都可以将特征图看作网络的全局状态，并且可以将自己的<code>k</code>个特征图添加到这个全局状态中。<strong>增长率 <code>k</code> 调节每一层对全局状态贡献的新信息量。</strong>全局状态一经编写，就可以从网络的任何地方进行获取，并且与传统网络不同，不需要从一层复制到另一层。</li></ul></li><li><p><strong>Bottleneck layers</strong></p><ul><li>尽管每一层仅产生 k 个特征图，但它通常情况下拥有更多的输入。在每个 3x3 卷积前引入 1x1卷积作为瓶颈层（bottleneck layer ），可以减少输入特征图的数量，从而可以提高计算效率。</li><li>这样的设计对于 DenseNet 特别有效，即网络中的 bottleneck layer  ：由 $BN-ReLU-Conv(1×1)-BN-ReLU-Conv(3×3)$ 组成 $H_l$ 版本 DenseNet 称为 <strong>DenseNet-B</strong>。（B 代表 Bottleneck）</li><li>在本文的实验中，我们令每个 $1×1$ 卷积产生 $4k$ 个特征图（k 应该是增长率）。</li></ul></li><li><p><strong>Compression：</strong></p><ul><li>为了进一步提高模型的紧凑性，我们可以在过渡层减少特征图的数量。</li><li>如果一个密集块 （dense block） 包含<code>m</code>个特征图，我们让其后的过渡层（transition layer）输出 $\lfloor \theta m \rfloor$ 个特征图。其中 $0 &lt; \theta \leq 1$ 被称作<strong>压缩因子（compression factor）</strong>。</li><li>当 $θ=1$ 时，通过过渡层的特征图数量不变，我们在实验中设置 $θ=0.5$</li><li>我们将同时使用了 bottleneck layer 和 $\theta &lt; 1$ 的transition layer 的 DenseNet 称作 <strong>DenseNet-BC</strong>。（ Bottleneck + Compression）</li></ul></li><li><p><strong>Implenentation Details</strong> 实现细节：</p><ul><li><p>除了 ImgageNet 以外的所有数据集，我们实验中使用的 DenseNet 都有三个 dense block ，每个块内的层数都是相等的。</p><ul><li>在进入第一个 dense block 之前，在输入图像上进行具有16 个输出通道的卷积（或者具有两倍 growth rate $k$ 的）DenseNet-BC。</li><li>对于卷积核大小（kernel size）为 3x3 的卷积层，输入的每一侧都被填充一个像素，以保持特征图的大小不变。</li><li>我们在1x1的卷积后跟一个2x2的平均池化层作为过渡层连接两个相邻的密集块。</li><li>在最后一个密集块（ dense block ）之后，执行一个全局平均池化（global average pooling），然后附加一个 softmax 分类器。</li><li>三个 dense block 内的特征图尺寸分别为 32x32、16x16 和 8x8。</li><li>作者使用了参数为 {L=40，k=12}、{L=100，k=12} 和 {L=100，k=24}的基本 DenseNet 结构进行实验。</li><li>对于 DenseNetBC 结构，评估了参数为 {L=100，k=12}、{L=250，k=24}和{L=190，k=40} 的网络。</li></ul></li><li><p>在 ImageNet 上的实验中，在 224×224 的输入图像上，我们使用了具有4个 dense block 的 DenseNet-BC 结构。初始的卷积层中包含 $2k$ 个卷积（大小为 7×7，stride 为2）；其他所有层特征图的数量均为 $k$ 。在 ImageNet 上使用的确切网络配置如表1。</p><p><img src="/2020/06/01/dccn/3.png" style="zoom:200%;"></p></li></ul></li></ol><h2><span id="shi-yan">实验</span><a href="#shi-yan" class="header-anchor">#</a></h2><p>所有训练的网络都使用 SGD 梯度下降。</p><p>在 CIFAR 和 SVHN 上训练的 batch size为64，epoch 分别为 300 和 40 。初始学习率设置为0.1。</p><p>在 ImageNet 上，epoch 为 90，batch size 为 256，初始学习率设置为 0.1，在 epoch 为30和60的时候，学习率降低10倍。</p><h2><span id="tao-lun">讨论</span><a href="#tao-lun" class="header-anchor">#</a></h2><h3><span id="model-compactness-mo-xing-jin-cou-xing">Model compactness 模型紧凑型</span><a href="#model-compactness-mo-xing-jin-cou-xing" class="header-anchor">#</a></h3><p>通过直连接，由 DenseNet 中任何层学习得到的特征图都可以被所有的后续层所访问。这鼓励了网络中的特征虫咬，提供了更紧凑的模型。</p><p><img src="/2020/06/01/dccn/4.png" alt></p><p>left：显示了DenseNet-BC 始终是 DenseNet 参数效率最高的变体。</p><p>middle：为了达到相同的 accuracy ，DenseNet-BC 只需要 ResNet 大约 $\frac{1}{3}$ 的参数。</p><p>right：仅具有0.8M可训练参数的 DenseNet-BC 能够达到与具有10.2M参数的1001层（激活前）ResNet相当的精度。</p><h3><span id="implicit-deep-supervision-yin-shi-shen-du-jian-du">Implicit Deep Supervision 隐式深度监督</span><a href="#implicit-deep-supervision-yin-shi-shen-du-jian-du" class="header-anchor">#</a></h3><p> DenseNet 的 accuracy 得到提升的一种解释是各个层通过 the shorter connections 接受到了来自 loss function 的额外监督。可以将 DenseNet 解读为一种 “deep supervision”。深度监督的好处是它将分类器附加到每个隐藏层，强制中间层学习具有区别性特征。</p><p>DenseNets 隐式执行类似的深度监督，网络顶部的单个分类器通过两到三个过渡层向所有层提供直接监督。然而，DenseNet 的损失函数和梯度基本上没有那么复杂，因为相同的损失函数在所有层之间共享。</p><h3><span id="stochastic-vs-deterministic-connection">Stochastic vs. deterministic connection</span><a href="#stochastic-vs-deterministic-connection" class="header-anchor">#</a></h3><p>随机连接与确定性连接，在 dense convolutional networks 和 stochastic depth regularization of residual networks 之间存在一个有趣的联系。在 stochastic depth 中， residual networks 中的层被随机丢弃，从而产生和周围层的直接连接。由于池化层从不丢弃，因此网络会产生与DenseNet类似的连接模式。</p>]]></content>
      
      
      <categories>
          
          <category> paper-cv </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Point cloud learning</title>
      <link href="2020/04/30/3d-point-clouds/"/>
      <url>2020/04/30/3d-point-clouds/</url>
      
        <content type="html"><![CDATA[<h1><span id="san-wei-dian-yun-shen-du-xue-xi-yan-jiu-zong-shu">三维点云深度学习研究综述</span><a href="#san-wei-dian-yun-shen-du-xue-xi-yan-jiu-zong-shu" class="header-anchor">#</a></h1><p>论文：Deep Learning for 3D Point Clouds: A Survey</p><p>作者：Yulan Guo</p><p>时间：2019-12</p><h2><span id="yin-yan">引言</span><a href="#yin-yan" class="header-anchor">#</a></h2><p><strong>动机</strong>：Point cloud learning （点云学习）由于在视觉、自动驾驶、机器人等方面的广泛应用，近年来受到了广泛的关注。最近，随着点云的深度学习变得更加兴旺，人们提出了许多方法来解决这一领域的不同问题。为了促进未来的研究，本文对点云深度学习方法的最新进展进行了全面的综述。</p><span id="more"></span><p><strong>挑战</strong>：</p><ol><li><p>深度学习技术目前已经成为成功解决各种二维视觉问题的主流技术，点云的深度学习依然处于初级阶段。</p></li><li><p>深度神经网络处理点云所面临的独特挑战（例如数据集的小规模、高维和三维点云的非结构化性质）</p></li></ol><p><strong>意义</strong></p><ol><li>第一篇全面涵盖几个重要点云相关任务的深度学习方法的调查论文，包括三维形状分类、三维目标检测和跟踪以及三维点云分割。</li><li>与现有的综述不同，特别关注3D点云的深度学习方法，而不是所有类型的3D数据</li><li>介绍了点云深度学习的最新进展。因此，它为读者提供了最先进的方法</li><li>提供了在几个公开可用数据集上<u>对</u><u>现有方法进行的综合比较</u>，并提供了简要总结和有洞察力的讨论</li></ol><p><strong>论述的三个主要的任务</strong>：</p><ol><li>3D shape classification （三维形状分类）</li><li>3D object detection and tracking （三维对象检测和追踪）</li><li>3D point cloud segmentation （三维点云分割）</li></ol><p><strong>三维点云深度学习方法的分类</strong>：</p><p><img src="/2020/04/30/3d-point-clouds/a.png" alt="a"></p><h2><span id="2-3d-shape-classification">2、3D Shape Classification</span><a href="#2-3d-shape-classification" class="header-anchor">#</a></h2><p><strong>介绍</strong>：这类的方法通常先学习 embedding of each point （每个点的嵌入），然后使用 aggregation method （聚合方法）从 whole point cloud （整个点云）中 extract a global shape embedding  （提取全局形状嵌入） ，最终由几个全连接层来实现 classification （分类）。</p><p>基于对每个点进行 feature learning （特征学习）的方式，现有的 3D shape  classification methods （三维形状分类方法）可分为 <strong>projection-based networks</strong> （基于投影的网络）和 <strong>point-based networks</strong> （基于点的网络）。在本文中，我们主要关注基于点的网络，但也包括一些基于投影的网络以保证完备性。</p><ol><li><strong>Projection-based methods</strong> ：首先将一个 unstructured （非结构化）的点云投影到一个规则中间的表示中，然后利用成熟的2D或3D卷积来实现形状分类。</li><li><strong>point-based networks</strong>：基于点的方法直接作用于原始点云，而不需要任何体素化或投影。基于点的方法不会引入显式信息丢失，并且变得越来越流行。</li></ol><p><strong>按时间顺序概述3D shape classification 的一些里程碑的方法</strong>：</p><p><img src="/2020/04/30/3d-point-clouds/b.png" alt="b"></p><h3><span id="2-1-projection-based-networks-ji-yu-tou-ying-de-wang-luo">2.1 Projection-based Networks 基于投影的网络</span><a href="#2-1-projection-based-networks-ji-yu-tou-ying-de-wang-luo" class="header-anchor">#</a></h3><p>基于投影的网络将3D点云投影到不同的表示模式（例如，多视图、体积表示）中，以进行特征学习和形状分类。</p><h4><span id="2-1-1-multi-view-representation-duo-shi-jiao-biao-shi">2.1.1 Multi-view representation 多视角表示</span><a href="#2-1-1-multi-view-representation-duo-shi-jiao-biao-shi" class="header-anchor">#</a></h4><p>这些方法首先将3D对象投影到多个 views (视图) 中并提取相应的 view-wise features（视域特征），然后融合这些特征以实现准确的对象识别。<strong>关键挑战</strong>是如何将多个 view-wise features 聚合到一个有识别力的全局表示 global representation 中。</p><p><strong>现有的一些方法</strong>：</p><ol><li><strong>MVCNN</strong>： 开创性的工作，只是简单地 max-pools multi-view features(多视图特征) into a global descriptor（全局描述符），但是max-pooling 仅保留特定视图中的最大元素，从而会导致信息丢失。</li><li><strong>MHBN</strong>：  通过协调双线性 pooling 来集成局部卷积特征（local convolutional features），以产生紧凑的全局描述符（global descriptor）。</li><li>首先利用关系网络（relation network）来发现一组视图上的相互关系(例如，区域-区域关系和视图-视图关系)，然后聚集这些视图以获得可辨别的 3D object representation。</li><li>……</li></ol><h4><span id="2-1-2-volumetric-representation-ti-su-biao-shi">2.1.2 Volumetric representation 体素表示</span><a href="#2-1-2-volumetric-representation-ti-su-biao-shi" class="header-anchor">#</a></h4><ol><li>早期的方法通常使用建立在 3D point clouds （3D点云）的 volumetric representation（体表示：由称为体素的离散体组成）上的三维卷积神经网络(CNN)。</li><li>Wu et al. 提出了一种卷积深度 belief-based 的3D ShapeNets，用于从不同形状的三维形状中学习点的分布。虽然已经取得了令人鼓舞的性能，但是这些方法不能很好地扩展到密集的3D数据，因为计算和内存占用随着分辨率的提高而成倍增长。</li><li>为此，引入了一种层次紧凑的图结构(如八叉树 octree )来降低这些方法的计算和存储开销。eg：OctNet、Octree-based CNN… 与基于dense input grids的 baseline network 相比，OctNet对高分辨率点云所需的内存和运行时间要少得多 。</li><li>PointGrid的混合网络，该网络集成了点和网格表示，以实现高效的点云处理。</li></ol><h3><span id="2-2-point-based-networks-ji-yu-dian-de-wang-luo">2.2 Point-based Networks 基于点的网络</span><a href="#2-2-point-based-networks-ji-yu-dian-de-wang-luo" class="header-anchor">#</a></h3><p>根据用于每个点的特征学习的网络结构，这类方法可分为逐点MLP（pointwise MLP）、基于卷积（convolution-based）、基于图（graph-based）、基于数据索引的网络（data indexing-based networks）和其他典型网络。  </p><h4><span id="2-2-1-pointwise-mlp-networks">2.2.1 Pointwise MLP Networks</span><a href="#2-2-1-pointwise-mlp-networks" class="header-anchor">#</a></h4><p>这类方法使用多层感知器 MLP（Multi-Layer Perceptrons ）对各个点进行独立的建模，接着使用对称的函数来集成到全局特征。对于无序的3D点云数据，这类网络可以得到置换不变性。然而这样的方法并未考虑到3D点之间的几何关系，如下图3。</p><p><img src="/2020/04/30/3d-point-clouds/pw.png" alt="pw" style="zoom: 67%;"></p><p>作为先驱工作，<strong>PointNet</strong> 使用MLP学习Pointwise特征，接着使用最大池化层来提取全局的形状特征。最后的分类结果也使用MLP来得到。[26]也论证了，得到置换不变性的关键在于将所有表示（representations）加起来并且使用非线性变化。[26]也设计了基础的网络DeepSets来进行多种应用的实现，包括形状分类。</p><p>由于特征是针对PointNet[5]中的每个点独立学习的，因此各个点之间的局部结构信息无法得到。[27]提出了一种分层次的网络<strong>PointNet++</strong>，从各个点之间的邻居来获取细粒度的几何特征。（PointNet++的核心，其abstraction level 由采样层（the sampling layer）、分组层（the grouping layer）和PointNet层三层组成。PointNet++通过堆叠多个abstraction level，可以从局部几何结构中学习特征，并逐层抽象局部特征。）</p><p>因为PointNet的简单和有效性，许多工作都基于PointNet开展。（这里介绍了一些网络）</p><h4><span id="2-2-2-convolution-based-networks-ji-yu-juan-ji-de-wang-luo">2.2.2 Convolution-based Networks 基于卷积的网络</span><a href="#2-2-2-convolution-based-networks-ji-yu-juan-ji-de-wang-luo" class="header-anchor">#</a></h4><p>与2D卷积相比，由于点云的不规则性，3D点云的卷积核更难设置。根据卷积核的不同，目前的3D卷积网络可以被分为连续卷积网络（continuous convolution networks ）和离散卷积网络（discrete convolution networks），如下图所示。</p><p><img src="/2020/04/30/3d-point-clouds/cb.png" alt="cb" style="zoom: 67%;"></p><p><strong>3D Continuous Convolution Networks</strong>. <strong>3D连续卷积网络</strong></p><p>这类方法在连续的空间中定义卷积核，其中邻居点的权重与它和中心点的空间分布有关。</p><p><u>3D卷积可以解释为给定子集上的加权和</u>。MLP是学习权重的一种简单方法。作为RS-CNN[35]的核心层，RS-Conv将某个点周围的局部子集作为其输入，使用MLP的方法来进行卷积，学习低维关系到高维关系的映射。</p><p><u>一些方法还使用现有算法来执行卷积</u>。在PointConv[38]中，卷积被定义为对重要性采样的连续3D卷积的蒙特卡洛估计。卷积核由加权函数（由MLP层学到）和密度函数（由核密度估计和MLP层学到）组成。为了提升内存和计算效率，3D卷积被简化成两部分：矩阵乘法和2D卷积，在相同的参数设置下，内存消耗可减小64倍。</p><p><strong>3D Discrete Convolution Networks</strong>. <strong>3D离散卷积网络</strong></p><p>这类方法在标准的网格上定义卷积核，其中的邻居点的权重是其关于中心点的补偿（offset）。</p><p>[49]将非归一化的点云变换至归一化的网格，接着在各个网格上定义卷积核。与2D卷积不同（在各个像素上分配权重），所提的3D卷积核在网格内的所有点赋予相同的权重。对于给定点，邻域内所有点（在相同网格上）的平均特征通过之前的层来计算得到。接着，所有网格的平均特征通过加权和产生当前层的输出。</p><h4><span id="2-2-3-graph-based-networks-ji-yu-tu-de-wang-luo">2.2.3 Graph-based Networks 基于图的网络</span><a href="#2-2-3-graph-based-networks-ji-yu-tu-de-wang-luo" class="header-anchor">#</a></h4><p>基于图的网络将点云中的每个点视为图的一个顶点，并基于每个点的邻域来生成图的有向边。然后在<u>空间域或谱域</u>中执行特征学习[58]。典型的基于图的网络如图5所示。</p><p><img src="/2020/04/30/3d-point-clouds/gb.png" alt="gb" style="zoom: 67%;"></p><p><strong>Graph-based Methods in Spatial Domain 空间域中的基于图的方法</strong> .</p><p>这类方法在空间域中定义卷积和池化操作。卷积通过在空间邻域内的MLP实现，池化操作通过集成信息产生新的较粗的图。各个顶点的特征由坐标、激光强度、颜色来确定，各个边的特征由两个连接点的几何属性确定。</p><p>作为先驱工作，[58]将各个点视为图的顶点，利用有向边将顶点与其邻域内的点相连，接着使用Edge-Condition Convolution（使用生成filter的网络得到，MLP等）。最大池化用来集成邻域信息，图的粗化使用VoxelGrid[59]算法得到。首先通过卷积和池化的相互交错，再跟着为全局平均池化和全连接层来产生分类score。</p><p><strong>Graph-based Methods in Spectral Domain 谱域中的基于图的方法</strong>. </p><p>这些方法将卷积定义为谱的滤波，将其实现为图上的信号与图的拉普拉斯矩阵的特征向量的乘法。</p><h4><span id="2-2-4-data-indexing-based-networks-ji-yu-suo-yin-shu-ju-de-wang-luo">2.2.4 Data Indexing-based Networks 基于索引数据的网络</span><a href="#2-2-4-data-indexing-based-networks-ji-yu-suo-yin-shu-ju-de-wang-luo" class="header-anchor">#</a></h4><p>这些网络基于不同的数据索引结构(例如，八叉树和kd-树)来构建。在这些方法中，点特征是沿着树从叶节点到根节点分层学习得到的。 </p><h4><span id="2-2-5-other-networks">2.2.5 Other Networks</span><a href="#2-2-5-other-networks" class="header-anchor">#</a></h4><p>除了上述方法外，还提出了许多其他方案</p><p>表1：在ModelNet10/40基准上比较3D Shape Classification 结果，只关注基于点的网络（pointbased networks ），“#params”指的是相应模型的参数个数。“OA”表示 overall accuracy ，“MACC”表示表中的平均精度（mean accuracy ）。符号‘-’表示结果不可用。</p><p><img src="/2020/04/30/3d-point-clouds/sc.png" alt="sc" style="zoom: 67%;"></p><h2><span id="3-3d-object-detection-and-tracking">3、3D Object Detection and tracking</span><a href="#3-3d-object-detection-and-tracking" class="header-anchor">#</a></h2><h3><span id="3-1-3d-object-detection-wu-ti-jian-ce">3.1 3D Object Detection 物体检测</span><a href="#3-1-3d-object-detection-wu-ti-jian-ce" class="header-anchor">#</a></h3><p>与普通2D中目标检测方法类似，3D中的目标检测也可以分为两类：基于候选区域的方法和直接映射方法。</p><h4><span id="3-1-1-region-proposal-based-methods-ji-yu-hou-xuan-qu-yu">3.1.1 Region Proposal-based Methods 基于候选区域</span><a href="#3-1-1-region-proposal-based-methods-ji-yu-hou-xuan-qu-yu" class="header-anchor">#</a></h4><p>首先产生一些可能包含物体的区域（Proposals），接着对各个区域提取特征，来决定各个候选区域的物体类别。</p><p><strong>根据不同的产生候选区域的方法</strong>，这些方法可进一步分为三类：基于多视角的方法（multi-view based）；基于分割的方法（segmentation-based）以及基于锥体的方法（frustum-based methods）。  </p><h5><span id="multi-view-methods-duo-shi-jiao-de-fang-fa">Multi-view Methods 多视角的方法</span><a href="#multi-view-methods-duo-shi-jiao-de-fang-fa" class="header-anchor">#</a></h5><p>这类方法从不同的视角图像（雷达前景图（LiDAR front view），鸟瞰图（bird’s eye view (BEV) ），图像（image）等）中融合各个候选框的特征，来产生3D rotated boxes，如图7(A)所示。这些方法的计算成本通常很高。</p><p>在[4]中，Chen等人从鸟瞰图BEV中产生一组准确的3D候选框，并且将其投影到其它视角中（雷达前景图，RGB图像），接着将各个区域的特征组合到一起，来预测有方向的3D bounding boxes。尽管这种方法在0.25IOU， 300个候选框设置时达到了99.1%的recall，但是速度非常慢。</p><p><img src="/2020/04/30/3d-point-clouds/mv3d.png" alt="mv3d" style="zoom: 50%;"></p><p>后续的基于多视角的3D物体检测方法主要从以下两个方面来提升。</p><ul><li>（1）<strong>提出了很多方法来有效的融合不同模态之间的信息</strong>。<ul><li>为了针对小物体产生有较高recall的候选框，[97]提出了一种多模态的基于融合的区域生成网络（ a multi-modal fusion-based region proposal network）。首先使用裁剪和大小调整操作从BEV视图和image视图中提取大小相等的特征，然后使用 mean pooling 对这些特征进行融合。具体而言，他们对BEV（鸟瞰视角）空间中的每个点提取最近的对应点的图image 特征，接着通过将image特征投影至BEV空间的方法，使用双线性插值得到稠密的BEV的特征图。<strong>实验结果证明稠密的BEV特征图比起离散的image特征图和稀疏的LiDAR(雷达激光)特征图更加适合3D物体检测。</strong> </li><li>[99]提出了多任务，多感知器的3D物体检测网络来进行端到端的训练。具体而言，利用多种任务（2D物体检测，背景估计 ground  estimation，深度补偿  depth completion ），帮助网络学习到更好的特征表示。学习到的跨模态的表示，可进一步用来产生更准确的物体检测结果。实验证明这类方法在2D,3D,BEV detection 任务上有着非常好的提升，在TOR4D基准[100, 101]上超越了之前的SOTA。</li></ul></li><li>（2）<strong>其它的一些方法致力于提取输入数据更鲁棒的表示 representations  </strong><ul><li>[102]通过引入空间Channel注意力机制模块（Spatial Channel Attention  (SCA)  Module），探索了多尺度的环境信息，该模块可捕获全局的以及多尺度的场景环境，加强了有用的特征。同样的，他们还提出了一种 Extension Spatial Unsample  (ESU) 模块，通过组合多尺度的低层特征来获得具有丰富空间信息的高层特征，从而生成更可靠的3D物体候选框 （proposals） 。尽管达到了更好的检测效果，但上述所提的多视角方法都需要较长的运行时间，因为他们对每个候选框都进行了特征的池化。因此，[103]使用了 预ROI池化卷积（pre-ROI pooling convolution）来提高[4]的效率。具体而言，他们将大部分的卷积操作移动到 RoI pooling 模块之前。因此，对于所有的物体候选框，ROI卷积只使用一次。实验结果显示这类方法可达到11.1fps, 速度达到了MV3D[4]的5倍。</li></ul></li></ul><h5><span id="segmentation-based-methods-ji-yu-fen-ge-de-fang-fa">Segmentation-based Methods 基于分割的方法</span><a href="#segmentation-based-methods-ji-yu-fen-ge-de-fang-fa" class="header-anchor">#</a></h5><p>这些方法首先利用现有的语义分割技术去除大多数背景点，然后在前景点上生成大量高质量的候选框，以节省计算量，如图7(B)所示。</p><p><img src="/2020/04/30/3d-point-clouds/sb.png" alt="sb" style="zoom: 67%;"></p><p>与刚刚的多视角Multi-view的方法[4],[97],[103]相比，这类方法达到了更好的物体recall，并且更适合一些目标高度遮挡和拥挤的复杂场景。</p><p>[104]中，Yang et al使用了2D的分割网络来预测前景（foreground pixels）的像素并将其投影至点云中，以此来剔除掉多数的背景点。接着在这些前景点中生成候选框，并且设计了一种新的标准称之为PointsIoU来减少候选框的冗余性和模糊性。</p><p>跟着[104]的脚步，[105]提出了PointRCNN的框架。具体而言，他们直接对3D点云进行分割，然后得到前景点，并且将语义特征和局部空间特征融合从而得到高质量的3D boxes。</p><p>[106] following [105]中的RPN，提出了一种利用图卷积网络来进行3D物体检测。具体而言，利用图卷积，引入了两个模块来改进refine物体的候选框。第一个模块R-GCN利用一个候选框中的所有点，得到每个候选框的特征集成。第二个模块C-GCN将所有候选框中的每一帧信息融合起来，利用环境来回归准确的物体boxes。</p><p>[107]将点云投影至基于图像 image-based 的分割网络的输出，并将语义预测值附加到这些点上。</p><p>[109]得到了显著的性能提升，通过将涂色的点送入至一些检测器中[105, 108]。</p><p>[110]将每个点与spherical anchor相关联，每个点的语义值用来移除多余的anchors。这样的方法得到了更好的recall以及有着更小的计算消耗。与此同时，文中提出了PointsPool层，对候选框中的内部点学习相容的特征（compact features），并且引入了并行的IoU来提高位置的准确度的检测性能。</p><p>实验结果证实这样的方法在KITTI数据集[10]上较难的集合（car class）的性能比[99, 105, 111]的性能优越很多，并达到了12.5fps。</p><h5><span id="frustum-based-methods-ji-yu-zhui-ti-de-fang-fa">Frustum-based Methods 基于椎体的方法</span><a href="#frustum-based-methods-ji-yu-zhui-ti-de-fang-fa" class="header-anchor">#</a></h5><p>这类方法首先利用现有的2D物体检测子，产生2D的候选矩形框，接着对每个2D的候选框提取3D的锥体候选框，如下图所示。尽管这类方法可以有效地给出3D物体的坐标，但step-by-step步进式的pipeline流水线使得它们的性能受到2D图像检测子的限制。</p><p><img src="/2020/04/30/3d-point-clouds/fb.png" alt="fb" style="zoom: 67%;"></p><p>F-PointNets[112]为此类detection方向的先驱工作。它在每个2D区域上产生一个锥形的候选框（frustum proposal），并且应用PointNet[5] ( 或PointNet++[27] ) 来学习各个3D锥体的点云特征，从而进行3D box的估计。</p><p>在随后的工作中，[113]提出了Point-SENet模块，来预测一系列的缩放因子，从而被用来突出有用特征和抑制无用特征。同时他们也将PointSIFT[114]模块集成至网络中，来获取点云的方向信息，其可以得到对形状尺度的强鲁棒性。该方法在[10], [115]的数据集上，与F-PointNets[112]相比得到了显著的提高。</p><p>方法[116]利用了2D image 区域和对应的锥体点来回归3D boxes。为了融合image 特征和点云的全局特征，他们提出了全局的融合网络来直接回归box的角坐标。他们也提出了稠密的网络网络来预测各个点对于各个角的补偿（offsets）。</p><p>[117]第一次从2D图像中估计2D的bounding boxes和3D物体姿态，提取多个几何上可行的对象候选。这些3D候选对象被送入至box 回归网络来预测准确的3D物体boxes。</p><p>[111]对于各个2D区域，在锥体轴上产生一系列的锥体，并使用PointNet来对各个锥体提取特征。锥体层次的特征用来产生2D特征图，再被送入至FCN 全连接网络来估计3D box。该方法在基于2D图像的方法中达到了state-of-the-art的性能，并且在KITTI积分榜上排在很靠前的位置。</p><p>[118]首先在鸟瞰图BEV上得到初步的检测结果，接着基于鸟瞰图的预测结果，提取小部分点的子集，再应用局部的微调网络来学习局部特征，预测高精度的3D bounding boxes。</p><h5><span id="qi-ta">其他</span><a href="#qi-ta" class="header-anchor">#</a></h5><p>……</p><h4><span id="3-1-2-single-shot-methods-zhi-jie-ying-she">3.1.2 Single Shot Methods 直接映射</span><a href="#3-1-2-single-shot-methods-zhi-jie-ying-she" class="header-anchor">#</a></h4><p>这类方法使用单阶段的网络，直接预测类别概率和回归物体的3D bounding boxes。这类方法不需要产生区域候选框和后处理。结果是，这类方法有着很快的速度，很适合实时的应用。<strong>根据输入数据的形式</strong>，single shot方法可分为两类：<u>基于鸟瞰图的方法</u>和<u>基于点云的方法</u>。</p><h5><span id="bev-based-methods-ji-yu-niao-kan-tu-de-fang-fa">BEV-based Methods 基于鸟瞰图的方法</span><a href="#bev-based-methods-ji-yu-niao-kan-tu-de-fang-fa" class="header-anchor">#</a></h5><p><u>这类方法将BEV表示作为输入。</u></p><p>[100]将场景的点云离散化，使用FCN来预测物体的位置和航向角。该方法超越了大多数single shot 方法([125],[126],[127])并且达到了28.6fps。之后，[128]利用HP map（High-Definition 高清）提供的几何和语义先验信息，提高了[100]的鲁棒性和检测性能。</p><h5><span id="point-cloud-based-methods-ji-yu-dian-yun-de-fang-fa">Point Cloud-based Methods.  基于点云的方法</span><a href="#point-cloud-based-methods-ji-yu-dian-yun-de-fang-fa" class="header-anchor">#</a></h5><p><u>这类方法将点云转换至一般的表示（例如2D map），接着使用CNN来预测对象的类别和3D boxes</u>。</p><p>[125]提出了使用FCN进行 3D object detection 。他们将点云转换至2D point map，使用2D FCN来预测bounding boxes和物体的置信度。</p><p>之后，[126]将点云离散化至4D的张量，其维度分别为：长度，宽度，高度和channel，接着将2D FCN的方法延伸至3D来进行3D的物体检测（object detection）。与[125]相比，基于FCN的3D方法达到了大于20%准确率的收益，但是由于3D卷积核数据的稀疏性，消耗了更多的计算资源。</p><p>为了解决体素 voxels 稀疏性的问题，[127]利用了feature-centric voting scheme（特征为中心投票机制），为每个非空的体素生成一组的votes，最后通过将votes相加的方式得到卷积的结果。它的计算复杂度与被占据的体素数量成正比。</p><p>[130]通过堆叠多个稀疏3D CNN，构建了3D的backbone网络。这样的设计节约了内存并且加速了计算。这个3Dbackbone网络提取了丰富的物体检测的3D特征，并且并未引入计算量的负担。</p><p>[108]提出了基于体素的端到端的可训练框架VoxelNet。他们将点云分割成等间距的体素，将每个体素的特征编码成4D的张量。然后使用RPN（region proposal<br>network）网络来产生检测结果（detection results）。尽管该方法效果很好，但由于体素的稀疏性和3D卷积操作，该方法运行速度很慢。之后，[120]使用了稀疏的卷积网络[134]来提高[108]的推断效率。</p><p>[131]通过将图像和点云特征在早期融合的方式，扩展了VoxelNet的工作。具体而言，他们将[108]产生的非空体素投影至图像，使用预训练的网络对各个投影的体素提取图像特征。这些图像特征与体素特征相级联，来预测准确的3D boxes。这类方法利用了多模态的信息，来减少false postivies and negatives。</p><p>[109]提出了3D物体检测子称为PointPillars。该方法利用了PointNet来学习点云的特征，将这些学到的特征编码伪图像（pesudo images）。然后使用2D的物体检测流水线（pipeline）来预测3D bounding boxes（边界框）。PointPillars在Average Precision（平均精度 AP）的指标上，超越了大多数的融合方法（MV3D[4], RoarNet[117], AVOD[97]）。并且，PointPillars在3D和BEV KITTI benchmarks上达到了62fps。</p><h5><span id="other-methods">Other Methods</span><a href="#other-methods" class="header-anchor">#</a></h5><p>[132]提出了一种有效的3D目标检测子称之为LaserNet。该方法在各个点上预测bounding boxes的概率分布，然后结合各个点的分布来产生最后的3D object boxes。接着，点云的dense range view representation （密集视图(RV)表示）作为输入，使用 fast mean-shift algorithm来降低逐点预测产生的噪声。LaserNet在0到50米的范围内实现了最先进的性能，其运行时间明显低于现有的方法。</p><p>[133]扩展LaserNet以利用RGB图像提供的密集纹理(例如，50到70米)。具体来说，通过将3D点云投影至2D图像使得LiDAR点和image点关联，并利用这种关联将RGB信息融合到3D点中。他们还将3D语义分割作为辅助任务以learn better representations。该方法在保持LaserNet的高效率的同时，在长距离(例如50到70米)目标检测和语义分割方面都取得了显著的改进。</p><h3><span id="3-2-3d-object-tracking-3d-wu-ti-gen-zong">3.2 3D Object Tracking 3D物体跟踪</span><a href="#3-2-3d-object-tracking-3d-wu-ti-gen-zong" class="header-anchor">#</a></h3><p>给定一个物体在第一帧时的位置，目标跟踪的任务是估计它在之后帧的状态。由于3D物体跟踪可以使用点云中丰富的几何信息，人们期待用它来克服在2D图像上追踪任务的困难，包括遮挡，光照以及尺度的变化。</p><p>Siamese network……</p><h3><span id="3-3-3d-scene-flow-estimation">3.3 3D Scene Flow Estimation</span><a href="#3-3-3d-scene-flow-estimation" class="header-anchor">#</a></h3><p>类似于2D视觉中的光流估计，已经有几种方法开始从点云序列中学习有用的信息(如三维场景流、空间临时信息)。</p><p>[142]提出了FlowNet3D，在一系列连续点云中直接学习场景流（scene flows）。FlowNet3D通过flow embedding layer， 学习point-level的特征和运动特征（motion features）。然而FlowNet3D存在两个问题。第一，一些预测的运动向量（motion vectors）与真实值差别非常大；第二，很难将FlowNet应用至非静态的场景，尤其是有着可形变物体的场景。</p><p>为了解决该问题，[143]引入了余弦距离的损失函数来最小化预测值与真实值之间的夹角。同时，他们提出了point-to-plane的距离损失函数，来提高刚性的和动态的场景的准确率。实验结果显示这两种损失函数将FlowNet3D的准确率从57.85%提升至63.43%，并且加速和稳定了训练过程。</p><p>[144]提出了HPLFlowNet（Hierarchical Permutohedral Lattice FlowNet ），从大规模的点云中直接估计场景流。文中提出了一些bilateral convolutional layers来存储结构信息，同时降低计算消耗。</p><p>为了有效地处理序列点云，[145]提出了PointRNN, PointGRU和PointLSTM，以及一个sequence-to-sequence model 来追踪移动点（moving points）。PointRNN, PointGRU和PointLSTM能够捕捉空间-时间信息，并且建模动态的点云。</p><p>类似地，[146]提出了MeteorNet来直接从动态点云中学习表示。该方法试图从时间和空间上的邻近点学习总体特征。</p><p>[147]提出了两个自监督的损失函数，在大量无标签的数据集上训练网络。他们的主要思想是：一种鲁棒的场景流估计方法应该在向前预测和向后预测时均有效。由于场景流标注不可用，预测得到的转换后的点的最近点，被当做是假想的真实值。然而，真正的真实值可能与它不同。为了避免这个问题，他们在相反的方向计算场景流，并且提出了cycle consistency loss。实验结果显示这种自监督的方法超过了现有自监督学习方法中的SOTA（state-of-the-art）性能。</p><h3><span id="3-4-summary">3.4 Summary</span><a href="#3-4-summary" class="header-anchor">#</a></h3><p>KITTI基准是自动驾驶领域中最有影响力的，并且在学术和工业领域有着广泛的应用。表2和表3展示了不同方法在KITTI test 3D and BEV benchmark上的结果。</p><p><img src="/2020/04/30/3d-point-clouds/t2.png" alt="t2" style="zoom: 67%;"></p><p><img src="/2020/04/30/3d-point-clouds/t3.png" alt="t3" style="zoom: 67%;"></p><p>可以观察到：</p><ul><li>Region proposal-based methods 是最常见的方法，在KITTI test 3D， BEV上的性能均超出了single shot methods。</li><li>现有的3D目标检测子（3D object detectors）有两个限制。第一，长范围的检测能力较弱。第二，如何充分利用图像中的纹理信息（texture information）仍然是个公开的问题。</li><li>多任务学习（ Multi-task learning）是在3D目标检测中未来的方向。例如，[99]通过合并多种任务，学习跨模态的表示来得到SOTA的检测效果。</li><li>3D物体跟踪（ 3D object tracking）和场景流估计（scene flow  estimation）是较新的研究方向，自2019年来受到越来越多的关注。</li></ul><h2><span id="4-3d-point-cloud-segmentation">4、3D Point Cloud Segmentation</span><a href="#4-3d-point-cloud-segmentation" class="header-anchor">#</a></h2><p>3D点云分割既需要了解全局的几何结构，又需要了解每个点的细粒度细节。根据分割的粒度，3D点云分割方法可分为以下三类：语义分割（场景级 scene level)）、实例分割（物体级 object level）和 part segmentation（part level）。</p><h3><span id="4-1-3d-semantic-segmentation-3d-yu-yi-fen-ge">4.1 3D Semantic Segmentation 3D 语义分割</span><a href="#4-1-3d-semantic-segmentation-3d-yu-yi-fen-ge" class="header-anchor">#</a></h3><p>给定一个点云，语义分割的目标是，根据语义信息，将各个点分成一定的子集。与3D shape classification（第2节）的分类类似，语义分割可分为两种方法：基于投影的方法和基于点的方法。</p><h4><span id="4-1-1-projection-based-networks-ji-yu-tou-ying-de-wang-luo">4.1.1 Projection-based Networks 基于投影的网络</span><a href="#4-1-1-projection-based-networks-ji-yu-tou-ying-de-wang-luo" class="header-anchor">#</a></h4><p>Intermediate regular representations（中间正则表示）可被分成以下几种：多视角(multi-view)表示[148], [149]、球状(spherical)表示[150], [151], [152]、体素(volumetric)表示[153], [154], [155]、超多面体晶格(permutohedral lattice )表示[156], [157]以及混合(hybrid)表示[158], [159]。具体可见下图。</p><p><img src="/2020/04/30/3d-point-clouds/pb.png" alt="pb" style="zoom: 50%;"></p><h5><span id="4-1-1-1-duo-shi-jiao-biao-shi-multi-view-representation">4.1.1.1 多视角表示 Multi-view Representation</span><a href="#4-1-1-1-duo-shi-jiao-biao-shi-multi-view-representation" class="header-anchor">#</a></h5><p>[148]首先将3D点云从多个虚拟的相机视角投影至2D平面上，接着，使用 multi-stream FCN 对合成图像进行像素级分数预测。最终，通过融合不同视图上的重投影分数（re-projected scores ）来获得每个点的最终语义标签。</p><p>相似地，[149]首先利用多个相机位置，得到点云的一些RGB和深度图快照。接着使用2D segmentation networks ，对这些快照进行像素级的标注label，使用残差校正(residual correction)进一步融合从RGB和深度图像预测的分数。</p><p>基于点云是从局部欧式曲面上采样得到的假设， [161]引入了tangent convolutions进行稠密的点云分割。该方法首先将各个点周围的局部曲面投影至虚拟的切平面。Tangent convolutions在曲面上直接进行。该方法具有很强的可扩展性，能够处理几百万个点的大规模点云。</p><p>总的来说，多视角分割方法的性能对视角的选择(viewpoint selection)和遮挡(occlusions)非常敏感。同时，这类方法并未能完全利用潜在的几何和结构信息，因为投影操作不可避免地引入了信息损失。</p><h5><span id="4-1-1-2-qiu-zhuang-biao-shi-spherical-representation">4.1.1.2 球状表示 Spherical Representation</span><a href="#4-1-1-2-qiu-zhuang-biao-shi-spherical-representation" class="header-anchor">#</a></h5><p>为了得到更快更准确的3D点云分割，[150]提出了基于SqueezeNet和条件随机场(Conditional Random Field (CRF))的端到端的网络。</p><p>为了进一步提升分割准确率，引入了SqueezeSegV2[151]，通过使用无监督的domain adaptationpipeline  解决domain shift 问题。</p><p>[152]提出了RangeNet++，针对LiDAR点云进行<u>实时</u>语义分割。首先将2D深度图像的语义标签转移至3D点云上，然后使用基于KNN的后处理步骤来减缓离散化误差和推理输出模糊的问题。</p><p>与单一的视角映射相比，球映射保持了更多的信息，并且更适合激光雷达（LiDAR）点云的标注。然而，这样的中间表示不可避免地引入了一些问题，比如离散化误差和遮挡问题。</p><h5><span id="4-1-1-3-ti-su-biao-shi-volumetric-representation">4.1.1.3 体素表示 Volumetric Representation</span><a href="#4-1-1-3-ti-su-biao-shi-volumetric-representation" class="header-anchor">#</a></h5><p>[163]首先将点云分成一系列占有的体素（occupancy voxels）。接着将这些中间数据送入至fully-3D CNN中进行体素级别的segmentation。最后，为一格体素（a voxel）内的所有点分配与该体素相同的语义标签label。该方法的性能极其受限于体素粒度(granularity of the voxels )和点云分割引起的边界伪影(boundary artifacts)。</p><p>之后，[164]提出SEGCloud来得到更细粒度和全局一致(global consistent)的语义分割。该方法引入了确定性的三线性插值，将由3D-FCNN产生的粗糙的体素预测映射回点云中，接着使用Fully Connected CRF，确保推测出的点云有着空间上的一致性。</p><p>[153]引入了一种基于核的变分自编码器结构，对每个体素内部的局部几何结构进行编码。这里摒弃了binary occupancy representations， 使用RBF得到连续的表示，并捕获到每个体素中点的分布。再使用VAE将各个体素中的点分布映射至紧凑的隐空间，最后使用CNN得到鲁棒的特征表示。</p><p><u>良好的可扩展性是体素表示中的优点之一</u>。具体而言，基于体素的网络（volumetric-based networks）可以在不同空间大小的点云中自由训练和测试。在Fully-Convolutional Point Network（FCPN）中，首先从点云中提取出来不同级别的几何相关性，再使用3D卷积和加权的average pooling 来提取特征、合并依赖关系。该方法可处理大规模的点云，并且在推断时有着良好的尺度扩展性质(scalability)。</p><p>[166]提出了ScanComplete来实现3D补全，以及对各个体素进行语义标注。该方法利用了全卷积网络(fully-convolutional neural networks)的尺度扩展性(scalability)，在训练和测试阶段可以适应不同大小的输入数据。使用从粗到细的策略来提高预测结果的分辨率。</p><p>很自然地，体素表示是稀疏的，其中非零元素的数量仅仅占很小一部分。因此，在空间上稀疏的数据使用稠密的卷积网络是比较无效的。为此，[155]提出了子流形的稀疏卷积网络( submanifold sparse convolutional networks)。该方法通过限制卷积的输出只能与被占据的体素有关，从而显著降低了内存和计算成本。同时，该稀疏卷积还可以控制提取出的特征的稀疏性。该子流形稀疏卷积很适合处理高维度且空间较稀疏的数据。</p><p>更进一步，[167]提出了一种用于三维视频感知的4D时空卷积神经网络（4D spatio-temporal convolutional neural network）“Minkowski Net”。</p><p>综上所述，体素表示很自然地保留了3D点云的邻域结构。其规范的数据形式还允许直接应用标准3D卷积。这些因素导致了该领域性能的稳步提高。然而，体素化的过程内在地引入了离散化的伪影和信息损失。通常，高分辨率会导致较高的内存和计算消耗，低分辨率引入了信息的损失。在实际中如何选择合适的网格分辨(grid resolution)率是non-trivial(不平凡的)的。</p><h5><span id="4-1-1-4-chao-duo-mian-ti-jing-ge-biao-shi-permutohedral-lattice-representation">4.1.1.4 超多面体晶格表示 Permutohedral Lattice Representation</span><a href="#4-1-1-4-chao-duo-mian-ti-jing-ge-biao-shi-permutohedral-lattice-representation" class="header-anchor">#</a></h5><p>[156]提出了基于双边卷积层（Bilateral convolution layers -BCLs）的稀疏晶格网络（Sparse Lattice Networks -SPLATNet）。该方法首先将原始点云插入至超多面体稀疏晶格(permutohedral sparse lattice)，再使用BCL对占据的部分进行卷积。得到的输出再重新插回原始点云。此外，该方法还允许灵活地联合处理多视图图像和点云。</p><p>更进一步，[157]提出了LatticeNet来实现有效的处理大规模点云。还引入了与数据相关的插值模块 DeformsSlice，将格点要素(lattice feature)反投影到点云中</p><h5><span id="4-1-1-5-hun-he-biao-shi-hybrid-representation">4.1.1.5 混合表示 Hybrid Representation</span><a href="#4-1-1-5-hun-he-biao-shi-hybrid-representation" class="header-anchor">#</a></h5><p>为了进一步利用所有可用信息，许多方法试图学习多模态特征(multi-modal features )。</p><p>[158]提出了joint 3D-mult-view网络，来组合RGB 特征和几何特征。一个3D CNN stream 和一些2D CNN stream用来提取特征，另一个可微分的back-projection layer用来合并3D和2D特征。</p><p>更进一步，[168]提出了unified point-based network来学习2D纹理信息，3D结构和全局特征。该方法直接应用基于点的网络(point-based networks)来提取局部几何特征和环境信息。</p><p>[159]提出了Multiview PointNet（MVPNet）来集成2D多视角特征和空间几何特征。</p><h4><span id="4-1-2-point-based-networks-ji-yu-dian-de-wang-luo">4.1.2 Point-based Networks 基于点的网络</span><a href="#4-1-2-point-based-networks-ji-yu-dian-de-wang-luo" class="header-anchor">#</a></h4><p>基于点的网络直接在点云上进行操作。然而，点云通常是无序且无结构的，使得直接应用标准的CNN不现实。为此，先驱的工作PointNet[5]用来对每个点进行特征学习，使用的是标准的MLP和全局特征。基于PointNet，一系列基于点的网络被提出。总体而言，这类方法可大致分为以下几类：<u>基于各个点的MLP方法</u>(pointwise MLP method)，<u>基于点卷积的方法</u>(point convolution methods)，<u>基于RNN的方法</u>(RNN-based methods)和<u>基于图的方法</u>(graph-based methods)。</p><h5><span id="4-1-2-1-pointwise-mlp-methods">4.1.2.1 Pointwise MLP Methods</span><a href="#4-1-2-1-pointwise-mlp-methods" class="header-anchor">#</a></h5><p>这类方法通常利用共享的MLP作为网络中的基本单元。然而，由共享MLP提取出的各个点上的特征，并不能获取到点云中的局部几何关系( local geometry)，以及点与点之间的关系(mutual interactions)[5]。为了获取各个点周围更广泛的信息，以及学习到更丰富的局部结构(local structures)，有很多方法被提出，包括<u>基于邻近点特征池化的方法</u>(methods based on neighboring feature pooling)，<u>基于注意力机制的集成</u>(attention-based aggregation)以及<u>局部-全局的特征级联</u>( local-global feature concatenation)。</p><p><strong>Neighboring feature pooling</strong></p><p>为了获取局部的几何形式，这类方法通过将局部邻域点集成的方式，对各个点学习特征。具体而言，PointNet++[27]将点分层次，逐步地分成一些组，如下图所示。多尺度的grouping和多分辨率的grouping来克服点云多样性造成的问题。</p><p><img src="/2020/04/30/3d-point-clouds/pn.png" alt="pn" style="zoom: 50%;"></p><p>之后，[114]提出了PointSIFT模块来实现方向的编码和scale awareness。该模块通过使用3阶段的有向的卷积操作，将8个空间方向的信息堆叠并且编码，将多尺度的特征提取并级联来实现对不同尺度的适应性。</p><p>与PointNet++中使用GROUPING的方法不同，[169]利用K-Means聚类和KNN的方法在世界空间和特征空间定义两种邻域。基于这样的假设：来自于同一类的点在特征空间中应当接近，该论文提出了pairwise distance loss and a centroid loss来对特征学习进行正则。</p><p>为了建模点与点之间的相互关系，[31]提出了PointWeb来寻找局部区域内所有点对之间的关系。[170]提出了置换不变性的卷积称之为Shellconv。[95]提出了有效、轻量的网络称为RandLA-Net实现大规模的点云处理。该方法利用随机样本采样，在内存和计算方面提升很多。提出的局部特征集成用来获取和保持几何特征。</p><p><strong>Attention-based aggregation</strong></p><p>为了进一步提升分割的准确率，[90]针对点云分割，提出了基于注意力的机制。</p><p>[29]提出了组随机注意力机制(group shuffle attention)来建模点之间的关系，并且提出了具有置换不变性、task-agnostic以及可微分的Gumbel Subset Sampling(GSS) ，来替代被广泛应用的Furthest Point Sampling(FPS)最远点抽样方法。该方法对离群点不敏感，并且可以选择具有代表性的点的子集。</p><p>为了更好地获取点云的空间分布，[171]提出了Local Spatial Aware(LSA)层来学习空间感知权重。</p><p>与CRF类似，[172]提出了Attention-based Score Refinement(ASR)模块对分割的结果进行后处理。初始分割结果通过pooling的方式进行修正。该模块很容易被集成至其他的深度网络中来提升分割效果。</p><p><strong>Local-global concatenation</strong></p><p>[85]提出了置换不变性的PS2-Net，将点云的局部结构(local structures)和全局信息(global context)合并。重复叠加Edgeconv[60]与NetVLAD[173]，以获取局部信息和场景级别的全局特征（scene-level global features）。</p><h5><span id="4-1-2-2-point-convolution-methods-dian-juan-ji-fa">4.1.2.2 Point Convolution Methods 点卷积法</span><a href="#4-1-2-2-point-convolution-methods-dian-juan-ji-fa" class="header-anchor">#</a></h5><p>这类方法通常试图提出在点云上进行更有效的卷积操作。</p><p>[49]提出了一种逐点卷积算子，其中邻域点被合并至kernel cell，然后与核权重进行卷积。</p><p>[174]提出了称之为PCCN的网络，该网络基于参数化的连续卷积层。该层的核函数由MLP参数化，横跨连续向量空间。</p><p>[42]提出了Kernel Point Fully Convolutional Network(KP-FCNN)，基于Kernel Point Convolution(KPConv)。具体而言，KPConv的卷积权重由欧式空间的距离决定，卷积核的点数（number of kernel points）也并不固定。卷积核点（kernel points）的位置由一个最优化问题确定。</p><p>在[175]中，作者提供了丰富的消融实验（ablation experiments）和可视化结果展示了集成方法中，感受野的重要性。同时他们提出了Dilated Point Convolution(DPC)操作，来集成邻近点的特征，进而取代KNN(K nearest neighbours)的方法。该方法在提升感受野（the receptive field）上非常有效，并且可以容易地集成至 aggregation-based networks。</p><h5><span id="4-1-2-3-rnn-based-methods">4.1.2.3 RNN-based Methods</span><a href="#4-1-2-3-rnn-based-methods" class="header-anchor">#</a></h5><p>为了从点云中获取固有的上下文特征(context features )，RNN也被用来进行点云的语义分割。</p><p>基于PointNet[5]， [180]首先将一大块点云转换成多尺度的块和网格块来获取输入级别的环境。接着，使用PointNet对各个块提取特征并送入Consolidation Units 或Recurrent Consolidation Units来获取输出级别的环境信息。实验结果显示，这样处理空间环境信息的方法在提高分割性能时是很重要的。</p><p>[179]提出了一种轻量的模块，利用了slice pooling layer将无序的点云特征转换成有序的特征向量。</p><p>[181]提出了Pointwise Pyramid Pooling (3P)模块来获取从粗到细的局部特征，并利用双向的RNN来实现端到端学习。然而这类方法损失了丰富的几何特征和密度分布[189]。</p><p>[189]提出了Dynamic Aggregation Network(DAR-Net)来同时考虑全局场景复杂度和局部几何特征。</p><p>[190]提出了3DCNN-DQN-RNN。该网络首先使用3DCNN学习空间分布和颜色特征，使用DQN进一步定位类别物体。最后级联的特征向量送入RNN中获取最后的分割结果。</p><h5><span id="4-1-2-4-graph-based-methods-ji-yu-tu-de-fang-fa">4.1.2.4 Graph-based Methods 基于图的方法</span><a href="#4-1-2-4-graph-based-methods-ji-yu-tu-de-fang-fa" class="header-anchor">#</a></h5><p>为了获取3D点云中潜在的形状和几何结构，一些方法使用了图神经网络（graph networks）。</p><p>[182]将点云看做是一些相连的简单形状和超点(Superpoint)的集合，并且使用属性有向图(attributed directed graph)（即超点图 superpoint graph ）获取结构和环境信息。接着，将大规模的点云分割问题分成三个子问题，即，geometrically homogeneous partition（几何均匀划分）, superpoint embedding（超点嵌入） and contextual segmentation（上下文分割）. </p><p>为了进一步提升，[183]提出了有监督的框架，来 oversegment a point cloud into pure superpoints（将点云过度分割为纯超点）。</p><p>为了更好地获取高维空间中的局部几何关系，[191]提出了基于Graph Embedding Module(GEM) 和 Pyramid Attention Network(PAN)的网络PyramNet。GEM模块将点云表述为有向无环图，并且在构建相似度矩阵时，利用协方差矩阵代替欧式距离。在PAN模块中，使用4个不同尺寸的卷积核来提取特征。</p><p>在[184]中，提出Graph Attention Convolution 用来从局部相邻集合中有选择性地学习相关特征。</p><h3><span id="4-2-instance-segmentation-shi-li-fen-ge">4.2 Instance Segmentation 实例分割</span><a href="#4-2-instance-segmentation-shi-li-fen-ge" class="header-anchor">#</a></h3><p>与语义分割  semantic segmentation 相比，实例分割更具有挑战性因为它需要更准确和更小的细粒度，具体而言，他不仅需要将有着不同语义的点分辨出来，还需要将有着相同语义的实例 (instance )分出来。总体而言，目前的方法可分为两个方向：<u>基于候选框的方法</u>(proposal-based)以及<u>不需要候选框的方法</u>(proposal-free)。一些里程碑式的方法具体见下图。</p><p>(按时间顺序概述了典型的三维点云实例分割方法)</p><p><img src="/2020/04/30/3d-point-clouds/is.png" alt="is" style="zoom: 50%;"></p><h4><span id="4-2-1-proposal-based-methods-ji-yu-hou-xuan-kuang">4.2.1 Proposal-based Methods 基于候选框</span><a href="#4-2-1-proposal-based-methods-ji-yu-hou-xuan-kuang" class="header-anchor">#</a></h4><p>这类方法将实例分割问题分成两个子任务：3D物体检测（3D object detection ）和实例mask的预测（instance mask prediction）。</p><p>[192]提出了3D fully-convolutional Semantic Instance Segmentation (3D-SIS) network，来实现在RGB-D数据上的语义实例分割。该网络从颜色和几何中学习特征。与3D object detection 类似，3D Region Proposal Network（3D-RPN）和 3D ROI layer用来预测bounding box的位置，物体类别和instance mask。</p><p>根据合成分析策略，[193]提出了Generative Shape Proposal Network(GSPN)来产生3D候选框。这些候选框再通过R-PointNet修正。最终的标签通过预测各个点的二进制mask来得到。与直接从点云数据回归三维边界框不同，该方法通过加强几何理解，去除了大量无用的候选框。</p><p>通过将2D全景分割( 2D panoptic segmentation)扩展到3D映射，[194]为实现大规模三维重建（3D reconstruction）、语义标注（semantic labeling）和instance segmentation，提出了一种在线三维映射系统（oneline volumetirc 3D mapping system）。该方法首先利用2D语义和实例分割网络来获得像素级的全景标签（panoptic labels ），然后将这些标签整合到 volumtric map 上。进一步使用全连接的CRF来实现准确的分割，该语义映射系统能够实现高质量的语义映射（ semantic mapping）和具有判别性的目标检测（object recognition）。</p><p>[195]提出了单阶段的，不需要anchor的端到端可训练网络—3D-BoNet，来实现点云上的 instance segmentation。该方法对所有可能的instance 直接回归大致的3D bounding boxes，接着利用点级别的二分类器（binary classifier）来获取实例标签。特别地，该 bounding box generation task是被当做是最优分配问题。同时，使用了multi-criteria 损失函数来正则化生成的bounding boxes。该方法不需要任何的后处理操作，并且有很高的计算效率。</p><p>[196]提出了针对大规模户外LiDAR点云进行instance segmentation的网络。该方法使用self-attention blocks，在点云的鸟瞰图上学习特征表示（feature representation），根据预测的水平中心和高度限制获得最终实例标签（instance labels）。</p><p>总的来说，基于候选框的方法较为直观，并且实例分割的结果通常较好。然而该方法需要多阶段的训练并且需要对多余候选框进行裁剪。因此通常都需要更多的时间和计算资源。</p><h4><span id="4-2-2-proposal-free-methods-bu-xu-yao-hou-xuan-kuang">4.2.2 Proposal-free Methods 不需要候选框</span><a href="#4-2-2-proposal-free-methods-bu-xu-yao-hou-xuan-kuang" class="header-anchor">#</a></h4><p>不需要候选框的方法[197-202]并没有目标检测的模块（ object detection module）。作为替代的是，他们通常将instance segmentation 认为是semantic segmentation （语义分割）后的聚类步骤。具体而言，需要现有的方法都基于这样的假设：属于同一实例的点应当有着相似的特征。因此这类方法通常聚焦于判别式的特征学习（discriminative feature learning）和点云聚类（point grouping）。</p><p>……</p><p>总体而言，不需要候选框的方法不需要耗费资源的区域生成步骤。然而，因为该方法不检测物体的边界，导致该方法的准确率较低。</p><h3><span id="4-3-part-segmentation">4.3 Part Segmentation</span><a href="#4-3-part-segmentation" class="header-anchor">#</a></h3><p>零件分割（part segmentation of 3D shapes）的主要困难来自于两方面。第一，有相同语义标签（ semantic label）的部件（shape parts）有着较大的几何变化和不确定性；第二，该方法需要对噪声和采样具有鲁棒性。</p><p>[208]提出了VoxSegNet，在3D体素数据上来实现细粒度的零件分割。</p><p>[209]将FCN与surface-based CRF组合，实现端到端的3D 零件分割。他们首先从不同的视角产生图像来实现optimal surface coverage，并将这些图片送入至2D网络产生置信图。接着，使用surface-based CRF 将置信图集成起来，用来对整个场景打标签。</p><p>[210]引入了Synchronized Spectral CNN(SyncSpecCNN)，在不规则非同构形状图上实现卷积。</p><p>[211]通过引入Shape Fully Convolutional Networks(SFCN),在3D网格上实现了形状分割，并且将三种低层次的几何特征作为输入。接着利用基于投票的多标签graph cut来修正分割结果。</p><p>[212]提出了弱监督的CoSegNet进行3D形状分割。该网络将一些未分割的3D点云形状作为输入，接着通过最小化group consistency loss，产生形状零件的标签。与CRF类似，预训练的part-refinement网络用来修正并且去噪。</p><p>[213]提出了Branched Auto-encoder network(BAE-NET)用来unsupervised ，one-shot和weakly supervised  3D shape co-segmentation。</p><h3><span id="4-4-summary">4.4 Summary</span><a href="#4-4-summary" class="header-anchor">#</a></h3><p>下表展示了已有方法在公开数据集上的结果，包括：S3DIS[176], Semantic3D[9], ScanNet[102]和SemanticKITTI[177].</p><p><img src="/2020/04/30/3d-point-clouds/ps.png" alt="ps" style="zoom: 50%;"></p><p>接下来这些问题需要进一步的探索。</p><ul><li>Point-based networks 是最常见的方法。然而，点的表示通常没有明确的邻域信息，现有的大多数基于点的方法不得不求助于昂贵的邻域搜索机制（KNN, ball query）。这自然地限制了这类方法的有效性，因为邻域查找方法需要很高的计算资源和内存。</li><li>在 point cloud segmentation 中，从不平衡的数据中学习仍然是具有挑战性的问题。尽管许多方法[42], [170], [182]达到了不错的结果，但性能在较小类别的数据上仍然较差。</li><li>大多数的方法[5], [27], [52], [170], [171]在较少点的点云上进行（4096）。实际上，从深度sensor上得到的点云是非常稠密的。因此需要寻求处理大规模点云的有效分割方法。</li><li>一些工作[145], [146], [167]开始在动态点云中学习空间-时间的信息，期望时空信息能够帮助提高后续任务（如3D对象识别[3D object recognition]、分割[segmentation]和补全[completion]）的性能。</li></ul><h2><span id="5-conclusion">5、CONCLUSION</span><a href="#5-conclusion" class="header-anchor">#</a></h2><p>本文章提出了当前针对3D understanding的一些SOTA方法，包括3D shape classification ，3D object detection &amp; tracking以及3D scene and object segmentation。对这些方法进行了全面的分类和性能比较。文中还介绍了各种方法的优缺点，并指出了可能的研究方向。</p><p>参考：</p><p><a href="https://zhuanlan.zhihu.com/p/103640399">1</a></p>]]></content>
      
      
      <categories>
          
          <category> paper-cv </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pytorch help</title>
      <link href="2020/04/21/pytorch-help/"/>
      <url>2020/04/21/pytorch-help/</url>
      
        <content type="html"><![CDATA[<h1><span id="pytorch-su-cha-shou-ce">Pytorch 速查手册</span><a href="#pytorch-su-cha-shou-ce" class="header-anchor">#</a></h1><p>希望整理曾经不懂的Pytorch用法，在以后以快速得到结果</p><span id="more"></span><h2><span id="1-guan-yu-tensors">1 关于Tensors</span><a href="#1-guan-yu-tensors" class="header-anchor">#</a></h2><p><strong>自我介绍</strong>：张量的英文是Tensor，它是PyTorch里面基础的运算单位，与Numpy的ndarray相同都表示的是一个多维的矩阵。 与ndarray的最大区别就是，PyTorch的Tensor<strong>可以在 GPU 上运行</strong>，而 numpy 的 ndarray 只能在 CPU 上运行，在GPU上运行大大加快了运算速度。</p><p>在同构的意义下，<strong>第零阶张量</strong> （r = 0） 为<strong>标量</strong> （Scalar），在同构的意义下， （r = 1） 为<strong>向量</strong> （Vector）， <strong>第二阶张量</strong> （r = 2） 则称为<strong>矩阵</strong> （Matrix）<strong>，第三阶以上</strong>的统称为<strong>多维张量</strong>。</p><ol><li><strong>torch.empty()</strong>：构造一个不初始化的张量 <code>x = torch.empty(5,3)</code></li><li><strong>torch.rand()</strong>：返回一个张量，包含了从区间[0, 1)的均匀分布中抽取的一组随机数  <code>x = torch.rand(5,3)</code> 5行3列的的矩阵</li><li><strong>x.shape</strong>：可以使用与numpy相同的shape查看张量大小 <code>print(x.shape)</code> torch.Size([2, 3])</li><li><strong>size()</strong>：使用size()函数，效果与shape相同 <code>x.size()</code>  torch.Size([2, 3])</li><li><strong>torch.zeros()</strong> ：构造全0矩阵 <code>x = torch.zeros(5, 3, dtype=torch.long)</code></li><li><strong>torch.ones()</strong>：返回一个张量，全1 <code>x = torch.ones(2, 2)</code></li><li><strong>torch.eye()</strong>：初始化一个单位矩阵，即对角线为1 其他为0，<code>eye=torch.eye(2,2)</code></li><li><strong>torch.randn()</strong>：返回一个张量，包含了从标准正态分布（均值为0，方差为1，即高斯白噪声）中抽取的一组随机数。<code>torch.randn(2, 3)</code></li><li><strong>torch.linspace(start, end, steps=100, out=None)</strong> → Tensor：返回一个1维张量，包含在区间start和end上均匀间隔的step个点。</li><li><strong>torch.tensor()</strong>：构造一个张量，直接使用数据 <code>x = torch.tensor([5.5, 3])</code></li><li><strong>x.new_ones()</strong>：基于已经存在的tensor创建一个张量 <code>x = x.new_ones(5, 3, dtype=torch.double)</code></li><li><strong>torch.randn_like()</strong>：<code>x = torch.randn_like(x, dtype=torch.float)</code> 会覆盖了以前的类型</li><li><strong>torch.size()</strong>：获取tensor的维度信息, torch.Size 是一个元组，所以它支持左右的元组操作。 <code>x.size()</code></li><li><strong>x + y</strong>：加法</li><li><strong>torch.add(x, y)</strong>：加法</li><li><strong>torch.add(x, y, out=result)</strong>：加法，结果赋给result <code>result = torch.empty(5, 3)</code></li><li><strong>y.add_(x)</strong>：把x加到y上面，直接覆盖y原来的值，<strong>以_为结尾的函数，均会改变调用值</strong>。</li><li><strong>x[:, 1]</strong>：输出第二列，注意索引从0开始</li><li><strong>torch.view</strong>()：改变一个tensor的大小或者性质<pre class=" language-lang-python"><code class="language-lang-python">x = torch.randn(4,4)  # torch.Size([4, 4])y = x.view(16) # 16维的一个list，不是矩阵了 torch.Size([16])z = x.view(-1, 8) # the size -1 is inferred from other dimensions  torch.Size([2, 8]</code></pre></li><li><strong>a.transpose(1, 2)</strong>：Swaps 2nd and 3rd dimension</li></ol><pre class=" language-lang-python"><code class="language-lang-python">a = torch.randn(1, 2, 3, 4) # torch.Size([1, 2, 3, 4])b = a.transpose(1, 2)  # torch.Size([1, 3, 2, 4])</code></pre><ol><li><strong>x.item()</strong>：对于标量（零阶张量），我们可以直接使用 .item() 从中取出其对应的python对象的数值；特别的：如果张量中只有一个元素的tensor也可以调用<code>tensor.item</code>方法。</li></ol><pre class=" language-lang-python"><code class="language-lang-python"># 标量scalar =torch.tensor(3.1433223)print(scalar) # tensor(3.1433)scalar.size() # torch.Size([])scalar.item() # 3.143322229385376# 只有一个元素的tensor，使用.item()来获得这个的value。x = torch.randn(1)print(x) # tensor([-1.7860])print(x.item()) # -1.7859678268432617print(x.size()) # torch.Size([1])loss = (y_pred - y).pow(2).sum().item()</code></pre><ol><li><p><strong>x.mm(y)</strong>：张量相乘（numpy中的x.dot(y)）</p></li><li><p><strong>x.t()</strong>：张量转置（numpy 中的x.T）</p></li><li><p><strong>x.clamp(min=0)</strong>：relu函数（numpy 中的np.maximum(h, 0)）</p></li><li><p><strong>x.clone()</strong>：张量复制（numpy 中的x.copy() ）</p></li><li><p><strong>.pow(2)</strong>：每个元素平方 <code>loss = (y_pred - y).pow(2).sum()</code></p></li><li><p><strong>数据类型</strong>：Tensor的基本数据类型有五种</p><ul><li>32位浮点型：torch.FloatTensor。 (默认) <code>tensor.float()</code></li><li>64位整型：torch.LongTensor。 <code>tensor.long()</code></li><li>32位整型：torch.IntTensor。<code>tensor.int()</code></li><li>16位整型：torch.ShortTensor。 <code>tensor.short()</code></li><li>64位浮点型：torch.DoubleTensor。</li><li>除以上数字类型外，还有 byte和chart型 <code>tensor.char()</code> <code>tensor.byte()</code></li></ul></li><li><p><strong>numpy和Tensor转换</strong>：</p><ul><li><pre class=" language-lang-python"><code class="language-lang-python">a = torch.randn((3, 2))# tensor转化为numpynumpy_a = a.numpy()</code></pre></li><li><pre class=" language-lang-python"><code class="language-lang-python"># numpy转化为Tensortorch_a = torch.from_numpy(numpy_a)torch_a</code></pre></li></ul></li><li><p><strong>torch.max()</strong>：eg：dim=1代表沿着行取最大值，<code>max_value, max_idx = torch.max(x, dim=1)</code></p></li><li><p><strong>torch.sum()</strong>：eg：每行 x 求和，<code>sum_x = torch.sum(x, dim=1)</code></p></li></ol><h2><span id="2-qiu-dao-xiang-guan">2 求导相关</span><a href="#2-qiu-dao-xiang-guan" class="header-anchor">#</a></h2><ol><li><p><strong>requires_grad=False</strong>：在张量创建时，通过设置 requires_grad 标识为Ture来告诉Pytorch需要对该张量进行自动求导，PyTorch会记录该张量的每一步操作历史并自动计算。<strong>默认为False</strong>，如果我们想计算某些的tensor的梯度，我们只需要在建立这个tensor时加入这么一句：requires_grad=True。<code>x = torch.rand(5, 5, requires_grad=True)</code></p></li><li><p><strong>x.grad</strong>：如果这个tensor x的requires_grad=True，那么反向传播之后x关于某个标量值的梯度会累积在张量 x.grad上。PyTorch会自动追踪和记录对与张量的所有操作，当计算完成后调用.backward()方法自动计算梯度并且将计算结果保存到grad属性中。</p></li><li><p><strong>.grad_fn</strong>：在张量进行操作后，grad_fn会被赋予一个新的函数，这个函数引用了一个创建了这个Tensor类的Function对象。 Tensor和Function互相连接生成了一个非循环图，它记录并且编码了完整的计算历史。每个张量都有一个.grad_fn属性，如果这个张量是用户手动创建的那么这个张量的grad_fn是None。</p></li><li><p><strong>with torch.no_grad():</strong>：在训练神经网络时，我们通常不希望通过权重更新步骤进行反向传播，使用<code>with torch.no_grad():</code>上下文管理器来防止构造计算图。使用上下文管理器临时禁止对已设置requires_grad=True的张量进行自动求导。这个方法<strong>在测试集计算准确率</strong>的时候会经常用到。使用.no_grad()进行嵌套后，代码不会跟踪历史记录，也就是说保存的这部分记录会减少内存的使用量并且会加快少许的运算速度。</p><pre class=" language-lang-python"><code class="language-lang-python">with torch.no_grad():        w1 -= learning_rate * w1.grad        w2 -= learning_rate * w2.grad        # 反向传播后手动将梯度设置为零        w1.grad.zero_()        w2.grad.zero_()</code></pre></li><li><p><strong>with torch.set_grad_enabled(False)</strong>：一个全局的环境，接下来所有的tensor运算产生的新的节点都是不可求导的；设置为True就是可以求导的了</p></li><li><p><strong>loss.backward()</strong>：.backward() 自动计算所有的requires_grad=True 张量的梯度，张量的梯度将累积到其<code>.grad</code>属性中。</p><pre class=" language-lang-python"><code class="language-lang-python">x = torch.rand(5, 5, requires_grad=True)x = torch.rand(5, 5, requires_grad=True)z=torch.sum(x+y)# 如果Tensor类表示的是一个标量（即它包含一个元素的张量），则不需要为backward()指定任何参数，但是如果它有更多的元素，则需要指定一个gradient参数，它是形状匹配的张量。 以上的 z.backward()相当于是z.backward(torch.tensor(1.))的简写。 这种参数常出现在图像分类中的单标签分类，输出一个标量代表图像的标签。x = torch.rand(5, 5, requires_grad=True)y = torch.rand(5, 5, requires_grad=True)z= x**2+y**3#我们的返回值不是一个标量，所以需要输入一个大小相同的张量作为参数，这里我们用ones_like函数根据x生成一个张量z.backward(torch.ones_like(x))print(x.grad)</code></pre></li><li><p><strong>↑Autograd 过程解析</strong>：Python的 <code>dir()</code> 返回参数的属性、方法列表。<code>z</code>是一个Tensor变量，看看里面有哪些成员变量。我们直接排除掉一些Python中特殊方法（以_开头和结束的）和私有方法（以<em>开头的，直接看几个比较主要的属性： <code>.is_leaf</code>：记录是否是叶子节点。通过这个属性来确定这个变量的类型，在官方文档中所说的“graph leaves”，“leaf variables”，都是指像<code>x</code>，<code>y</code>这样的手动创建的、而非运算得到的变量，这些变量成为<strong>创建变量</strong>。 像<code>z</code>这样的，是通过计算后得到的结果称为<em>*结果变量</em></em>。</p></li><li><p><strong>.is_leaf</strong>：一个变量是创建变量还是结果变量是通过<code>.is_leaf</code>来获取的。</p><pre class=" language-lang-python"><code class="language-lang-python">x = torch.rand(5, 5, requires_grad=True)y = torch.rand(5, 5, requires_grad=True)z= x**2+y**3print("x.is_leaf="+str(x.is_leaf)) # x.is_leaf=Trueprint("z.is_leaf="+str(z.is_leaf)) # z.is_leaf=False# x是手动创建的没有通过计算，所以他被认为是一个叶子节点也就是一个创建变量，而z是通过x与y的一系列计算得到的，所以不是叶子结点也就是结果变量。</code></pre></li><li><p><strong>为什么我们执行<code>z.backward()</code>方法会更新<code>x.grad</code>和<code>y.grad</code>呢？</strong></p><ul><li><p><code>.grad_fn</code>属性记录的就是这部分的操作，记录并且编码了完整的计算历史。</p><pre class=" language-lang-python"><code class="language-lang-python">z.grad_fn  # <addbackward0 at 0x120840a90># grad_fn是一个AddBackward0类型的变量</addbackward0></code></pre></li><li><p>我们 dir(z.grad_fn)，看看里面有什么东西？<code>next_functions</code> 就是<code>grad_fn</code>的精华！</p><pre class=" language-lang-python"><code class="language-lang-python">dir(z.grad_fn) # 'next_functions',z.grad_fn.next_functions # ((<powbackward0 at 0x1208409b0>, 0), (<powbackward0 at 0x1208408d0>, 0))# next_functions是一个tuple of tuple of PowBackward0 and int。# 为什么是2个tuple ？ 因为我们的操作是z= x**2+y**3 刚才的AddBackward0是相加，而前面的操作是乘方 PowBackward0。tuple第一个元素就是x相关的操作记录</powbackward0></powbackward0></code></pre></li><li><p>继续挖掘：在PyTorch的反向图计算中，<code>AccumulateGrad</code>类型代表的就是叶子节点类型，也就是计算图终止节点。<code>AccumulateGrad</code>类中有一个<code>.variable</code>属性指向叶子节点。</p><pre class=" language-lang-python"><code class="language-lang-python">xg = z.grad_fn.next_functions[0][0]dir(xg) # next_functionsx_leaf=xg.next_functions[0][0]type(x_leaf) # AccumulateGradx_leaf.variable # 这个.variable的属性就是我们的生成的变量xprint("x_leaf.variable的id:"+str(id(x_leaf.variable)))print("x的id:"+str(id(x)))# x_leaf.variable的id:4840553424# x的id:4840553424</code></pre></li><li><p>这样整个规程就很清晰了：</p><ul><li>当我们执行z.backward()的时候。这个操作将调用z里面的grad_fn这个属性，执行求导的操作。</li><li>这个操作将遍历grad_fn的next_functions，然后分别取出里面的Function（AccumulateGrad），执行求导操作。这部分是一个递归的过程直到最后类型为叶子节点。</li><li>计算出结果以后，将结果保存到他们对应的variable 这个变量所引用的对象（x和y）的 grad这个属性里面。</li><li>求导结束。所有的叶节点的grad变量都得到了相应的更新</li></ul></li></ul></li><li><p><strong>.detach()</strong>：停止tensor历史记录的跟踪，该tensor与计算历史记录分离，并防止将来的计算被跟踪。</p></li><li><p><strong>.grad.zero_()</strong>：将梯度设置为零 <code>w1.grad.zero_()</code></p></li><li><p><strong>.zero_grad()</strong>：手动将梯度缓冲区设置为零 <code>optimizer.zero_grad()</code></p></li><li><p><strong>torch.device()</strong>：应该是方便GPU上运行的 <code>device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')</code></p></li><li><p><strong>torch.autograd.Function</strong>：<strong>如果需要自定义autograd扩展新的功能</strong>，就需要扩展Function类。因为Function使用autograd来计算结果和梯度，并对操作历史进行编码。定义<code>torch.autograd.Function</code>的子类并三个方法，来<strong>定义自己的自动求导运算</strong></p><pre class=" language-lang-python"><code class="language-lang-python"># __init__ (optional)：如果这个操作需要额外的参数则需要定义这个Function的构造函数，不需要的话可以忽略。# forward()：执行前向传播的计算代码# backward()：反向传播时梯度计算的代码。 参数的个数和forward返回值的个数一样，每个参数代表传回到此操作的梯度。</code></pre><pre class=" language-lang-python"><code class="language-lang-python"># 调用 MyReLU.apply 函数来使用自定义的ReLUimport torchclass MyReLU(torch.autograd.Function):    # (输入参数是张量)    # 方法必须是静态方法，所以要加上@staticmethod     @staticmethod    def forward(ctx, x):         # ctx 用来保存信息这里类似self，并且ctx的属性可以在backward中调用        ctx.save_for_backward(x)        return x.clamp(min=0)    @staticmethod    def backward(ctx, grad_output):        x, = ctx.saved_tensors        grad_x = grad_output.clone()        grad_x[x < 0] =0        return grad_x# 详见 大刀阔斧，步步推进 # 调用 MyReLU.apply 函数来使用自定义的ReLUy_pred = MyReLU.apply(x.mm(w1)).mm(w2)</code></pre></li></ol><h2><span id="3-shu-ju-jia-zai-chu-li-xiang-guan">3 数据加载处理相关</span><a href="#3-shu-ju-jia-zai-chu-li-xiang-guan" class="header-anchor">#</a></h2><p><strong>相关头文件</strong></p><pre class=" language-lang-python"><code class="language-lang-python">from __future__ import print_function, divisionimport osimport torchimport pandas as pd              #用于更容易地进行csv解析from skimage import io, transform    #用于图像的IO和变换import numpy as npimport matplotlib.pyplot as pltfrom torch.utils.data import Dataset, DataLoaderfrom torchvision import transforms, utils# 忽略警告import warningswarnings.filterwarnings("ignore")plt.ion()   # interactive mode 在脚本中遇到plt.show()，代码还是会继续执行</code></pre><ol><li><p><strong>pd.read_csv()</strong>：读取csv数据 </p><pre class=" language-lang-python"><code class="language-lang-python">landmarks_frame = pd.read_csv('data/faces/face_landmarks.csv')n = 65img_name = landmarks_frame.iloc[n, 0] # 获取第65行第0列数据landmarks = landmarks_frame.iloc[n, 1:].as_matrix() # 将第1列以后的转化为矩阵landmarks = landmarks.astype('float').reshape(-1, 2)  # 将原本一行的数据转化为两行列，一列为x坐标，y坐标</code></pre></li><li><p><strong>.iloc[n, 1:]</strong>：数据切片，获取第n行，第1列以后的数据</p></li><li><p><strong>.as_matrix()</strong>：转化为矩阵</p></li><li><p><strong>.astype(‘float’)</strong>：转换格式</p></li><li><p><strong>.reshape(-1, 2)</strong>：重塑大小</p></li><li><p><strong>torch.utils.data.Dataset</strong>：表示数据集的抽象类，因此自定义的数据集应继承Dataset 并重载以下方法</p><ul><li><p><code>__len__</code> ：实现 <code>len(dataset)</code> 返回数据集的尺寸</p><ul><li><code>__getitem__</code>：用索引(<code>0</code> 到 <code>len(self)</code>)获取一条数据或一个样本</li><li><code>__init__</code>：读取csv的文件内容</li></ul><pre class=" language-lang-python"><code class="language-lang-python">class FaceLandmarksDataset(Dataset):  def __init__(self, csv_file, root_dir, transform=None):      self.landmarks_frame = pd.read_csv(csv_file)      self.root_dir = root_dir      self.transform = transform  def __len__(self):      return len(self.landmarks_frame) # 有多少样本（行）  def __getitem__(self, index):      img_name = os.path.join(self.root_dir, self.landmarks_frame.iloc[index, 0])      image = io.imread(img_name)      landmarks = self.landmarks_frame.iloc[index, 1:]      landmarks = np.array([landmarks])      landmarks = landmarks.astype('float').reshape(-1, 2)      sample = {'image': image, 'landmarks': landmarks}      if self.transform:          sample = self.transform(sample)      return sample</code></pre></li></ul></li><li><p><strong>torchvision.transforms.Compose</strong>：组合一个变换</p></li></ol><ul><li>Resize：把给定的图片resize到given size</li><li>transforms.ToTensor(), convert a PIL image to tensor <code>(H*W*C)</code> in range [0,255] to a torch.Tensor<code>(C*H*W)</code> in the range [0.0,1.0]  把[0,255]转换到[0.0, 1.0]</li><li>transforms.Normalize ：Normalized an tensor image with mean and standard deviation; </li><li>ToPILImage: convert a tensor to PIL image</li><li>Scale：目前已经不用了，推荐用Resize</li><li>CenterCrop：在图片的中间区域进行裁剪</li><li>RandomCrop：在一个随机的位置进行裁剪</li><li>RandomHorizontalFlip：以0.5的概率水平翻转给定的PIL图像</li><li>RandomVerticalFlip：以0.5的概率竖直翻转给定的PIL图像</li><li>RandomResizedCrop：将PIL图像裁剪成任意大小和纵横比</li><li>Grayscale：将图像转换为灰度图像</li><li>RandomGrayscale：将图像以一定的概率转换为灰度图像</li><li><p>ColorJitter：随机改变图像的亮度对比度和饱和度。</p><pre class=" language-lang-python"><code class="language-lang-python"> import torch from torchvision import transforms, datasets data_transform = transforms.Compose([         transforms.RandomSizedCrop(224),         transforms.RandomHorizontalFlip(),         transforms.ToTensor(),         transforms.Normalize(mean=[0.485, 0.456, 0.406],                              std=[0.229, 0.224, 0.225])     ]) hymenoptera_dataset = datasets.ImageFolder(root='hymenoptera_data/train', transform=data_transform) dataset_loader = torch.utils.data.DataLoader(hymenoptera_dataset,batch_size=4, shuffle=True,num_workers=4)</code></pre></li></ul><ol><li><p><strong>np.random.randint(0,n)</strong>：获取一个随机整数</p></li><li><p><strong>torch.utils.data.DataLoader</strong>：对所有数据集简单的使用for循环牺牲了许多功能，尤其是：批量处理数据、打乱数据。torch.utils.data.DataLoader是一个提供上述所有这些功能的迭代器。</p><pre class=" language-lang-python"><code class="language-lang-python"># 代码一般是这么写的：# 1. 定义学习集 DataLoadertrain_data = torch.utils.data.DataLoader(hymenoptera_dataset,batch_size=4, shuffle=True,num_workers=4,各种设置...)# 2.将数据喂入神经网络进行训练for i, (input, target) in enumerate(train_data):     循环代码行......# DataLoader中的几个重要参数# dataset：（数据类型 dataset）输入的数据类型# batch_size：（数据类型 int）每次输入数据的行数，默认为1,每次喂给神经网络多少行数据# shuffle：（数据类型 bool）洗牌。默认设置为False。在每次迭代训练时是否将数据洗牌，默认设置是False。将输入数据的顺序打乱，是为了使数据更有独立性，但如果数据是有序列特征的，就不要设置成True了。# num_workers：（数据类型 Int）工作者数量，默认是0。使用多少个子进程来导入数据。设置为0，就是使用主进程来导入数据。注意：这个数字必须是大于等于0的，负数估计会出错。# drop_last：（数据类型 bool）丢弃最后数据，默认为False。设置了 batch_size 的数目后，最后一批数据未必是设置的数目，有可能会小些。这时你是否需要丢弃这批数据。# timeout：（数据类型 numeric）超时，默认为0。是用来设置数据读取的超时时间的，但超过这个时间还没读取到数据的话就会报错。 所以，数值必须大于等于0。</code></pre><ul><li><p>DataLoader返回的是一个可迭代对象，我们可以使用迭代器分次获取数据</p><pre class=" language-lang-python"><code class="language-lang-python">dl = torch.utils.data.DataLoader(ds_demo, batch_size=10, shuffle=True, num_workers=0)idata=iter(dl)print(next(idata))</code></pre></li><li><p>常见的用法是使用for循环对其进行遍历</p><pre class=" language-lang-python"><code class="language-lang-python">for i, data in enumerate(dl):    print(i,data)    # 为了节约空间，这里只循环一遍    break</code></pre></li><li><p>我们已经可以<strong>通过dataset定义数据集</strong>，并<strong>使用Datalorder载入和遍历数据集</strong>，除了这些以外，PyTorch还提供能<strong>torcvision的计算机视觉扩展包</strong>，torchvision 是PyTorch中专门用来<strong>处理图像的库</strong>，里面封装了torchvision.datasets、torchvision.models、torchvision.transforms：</p><ul><li><p><strong>torchvision.datasets</strong>：torchvision.datasets 可以理解为PyTorch团队自定义的dataset，这些dataset帮我们提前处理好了很多的图片数据集，我们拿来就可以直接使用：</p><pre class=" language-lang-python"><code class="language-lang-python">MNISTCOCOCaptionsDetectionLSUNImageFolderImagenet-12CIFARSTL10SVHNPhotoTour # 示例如下：import torchvision.datasets as datasetstrainset = datasets.MNIST(root='./data', # 表示 MNIST 数据的加载的目录                                      train=True,  # 表示是否加载数据库的训练集，false的时候加载测试集                                      download=True, # 表示是否自动下载 MNIST 数据集                                      transform=None) # 表示是否需要对数据进行预处理，none为不进行预处理</code></pre></li><li><p><strong>torchvision.models</strong>：torchvision不仅提供了常用图片数据集，还提供了训练好的模型，可以加载之后，直接使用，或者在进行迁移学习。 torchvision.models模块的子模块中包含以下模型结构。</p><pre class=" language-lang-python"><code class="language-lang-python">AlexNetVGGResNetSqueezeNetDenseNet#我们直接可以使用训练好的模型，当然这个与datasets相同，都是需要从服务器下载的import torchvision.models as modelsresnet18 = models.resnet18(pretrained=True)</code></pre></li><li><p><strong>torchvision.transforms</strong>：transforms 模块提供了一般的图像转换操作类，用作数据处理和数据增强</p><pre class=" language-lang-python"><code class="language-lang-python">from torchvision import transforms as transformstransform = transforms.Compose([    transforms.RandomCrop(32, padding=4),  #先四周填充0，在把图像随机裁剪成32*32    transforms.RandomHorizontalFlip(),  #图像一半的概率翻转，一半的概率不翻转    transforms.RandomRotation((-45,45)), #随机旋转    transforms.ToTensor(),    transforms.Normalize((0.4914, 0.4822, 0.4465), (0.229, 0.224, 0.225)), #R,G,B每层的归一化用到的均值和方差])</code></pre><p>肯定有人会问：(0.485, 0.456, 0.406), (0.2023, 0.1994, 0.2010) 这几个数字是什么意思？这些都是根据ImageNet训练的归一化参数，可以直接使用，我们认为这个是固定值就可以</p></li></ul></li></ul></li><li><p><strong>torchvision.datasets.ImageFolder</strong>：torchvision包提供了常用的数据集类(datasets)和转换(transforms)，你可能不需要自己构造这些类。很常用的数据集类<strong>ImageFolder</strong>。 它假定了数据集是以如下方式构造的，其中’ants’,bees’等是分类标签。</p><pre class=" language-lang-python"><code class="language-lang-python">root/ants/xxx.pngroot/ants/xxy.jpegroot/ants/xxz.png.root/bees/123.jpgroot/bees/nsdf3.pngroot/bees/asd932_.pnghymenoptera_dataset = datasets.ImageFolder(root='hymenoptera_data/train',                                           transform=data_transform)</code></pre></li><li><p><strong>torch.unsqueeze()</strong>：对<strong>数据维度进行扩充</strong>。给指定位置加上维数为一的维度，比如原本有个三行的数据（3），在0的位置加了一维就变成一行三列（1,3）</p><ul><li><code>a.unsqueeze(N)</code>： 就是在a中指定位置N加上一个维数为1的维度</li><li><code>b=torch.unsqueeze(a，N)</code>: b就是在a中指定位置N加上一个维数为1的维度</li></ul></li><li><p><strong>torch.squeeze()</strong>：对<strong>数据的维度进行压缩</strong>，去掉维数为1的的维度，比如是一行或者一列这种，一个一行三列（1,3）的数去掉第一个维数为一的维度之后就变成（3）行。</p><ul><li><code>squeeze(a)</code>:a中所有为1的维度删掉，不为1的维度没有影响。</li><li><code>a.squeeze(N)</code> :去掉a中指定的维数为一的维度</li><li><code>b=torch.squeeze(a，N)</code> a中去掉指定的定的维数为一的维度。</li></ul></li><li><p><strong>torchvision.datasets</strong>：PyTorch通过torch.utils.data对一般常用的数据加载进行了封装，可以很容易地实现多线程数据预读和批量加载。 并且torchvision已经预先实现了常用图像数据集，包括前面使用过的CIFAR-10，ImageNet、COCO、MNIST、LSUN等数据集，可通过torchvision.datasets方便的调用</p></li></ol><h2><span id="4-wang-luo-da-jian-xiang-guan">4 网络搭建相关</span><a href="#4-wang-luo-da-jian-xiang-guan" class="header-anchor">#</a></h2><ol><li><p><strong>torch.nn</strong>：计算图和autograd是十分强大的工具，可以定义复杂的操作并自动求导；然而对于大规模的网络，autograd太过于底层，nn包中定义一组大致等价于层的模块。一个模块接受输入的tesnor，计算输出的tensor，而且还保存了一些内部状态比如需要学习的tensor的参数等。nn包中也定义了一组损失函数（loss functions），用来训练神经网络。</p></li><li><p><strong>torch.nn.Sequential()</strong>：nn.Sequential是包含其他模块的模块，并按顺序应用这些模块来产生其输出。</p><pre class=" language-lang-python"><code class="language-lang-python">model = torch.nn.Sequential(    torch.nn.Linear(D_in, H),    torch.nn.ReLU(),    torch.nn.Linear(H, D_out))y_pred = model(x) # 前向传播：通过向模型传入x计算预测的y。model.zero_grad() # 反向传播之前清零梯度</code></pre></li><li><p><strong>torch.nn.MSELoss(reduction=’sum’)</strong>：nn包还包含常用的损失函数的定义，这里使用平均平方误差(MSE)，设置<code>reduction='sum'</code>，表示我们计算的是评分误差的‘和’，而不是平均值，<code>reduction=‘elementwise_mean’</code>来使用均方误差作为损失更为常见</p><pre class=" language-lang-python"><code class="language-lang-python">loss_fn = torch.nn.MSELoss(reduction='sum')loss = loss_fn(y_pred, y)loss.backward()</code></pre></li><li><p><strong>torch.nn.Linear()</strong>：线性层 <code>torch.nn.Linear(D_in, H)</code></p></li><li><p><strong>torch.nn.ReLU()</strong>：ReLu 激活函数 </p></li><li><p><strong>model.parameters()</strong>：获取2中定义模型的所有参数</p><pre class=" language-lang-python"><code class="language-lang-python"># 使用梯度下降更新权重。# 每个参数都是张量，更新它的数值with torch.no_grad():        for param in model.parameters():            param -= learning_rate * param.grad</code></pre></li><li><p><strong>torch.optim</strong>：SGD、AdaGrad、RMSProp、Adam等更复杂的优化器来训练神经网络。</p><pre class=" language-lang-python"><code class="language-lang-python">optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)optimizer = torch.optim.SGD(model.parameters(), lr=1e-4, momentum=0.9)optimizer = optim.SGD(net.parameters(), lr=0.01)# 在反向传播之前，使用optimizer将它要更新的所有张量的梯度清零(这些张量是模型可学习的权重)optimizer.zero_grad()loss.backward() # 反向传播，根据模型参数计算loss的损失梯度optimizer.step() # 调用Optimizer的step函数使它所有参数更新</code></pre></li><li><p><strong>torch.nn.Module</strong>：需要指定比现有模块序列更复杂的模型；对于这些情况，可以通过继承nn.Module 并定义 forward 函数</p><pre class=" language-lang-python"><code class="language-lang-python">class TwoLayerNet(torch.nn.Module):    def __init__(self, D_in, H, D_out):        super(TwoLayerNet, self).__init__()        self.linear1 = torch.nn.Linear(D_in, H)        self.linear2 = torch.nn.Linear(H, D_out)    def forward(self, x):        h_relu = self.linear1(x).clamp(min=0)        y_pred = self.linear2(h_relu)        return y_pred# 通过实例化上面定义的类来构建我们的模型。model = TwoLayerNet(D_in, H, D_out)y_pred = model(x) # 前向传播：通过向模型传递x计算预测值y</code></pre><pre class=" language-lang-python"><code class="language-lang-python"># 详见《神经网络》import torchimport torch.nn as nnimport torch.nn.functional as Fclass Net(nn.Module):    def __init__(self):        super(Net, self).__init__()        # 1 input image channel, 6 output channels, 5x5 square convolution        self.conv1 = nn.Conv2d(1, 6, 5) # 输入1个通道，输出6个通道，5×5filter        self.conv2 = nn.Conv2d(6, 16, 5) # 输入6个通道，输出16个通道，5×5filter        # an affine operation: y = Wx + b        self.fc1 = nn.Linear(16 * 5 * 5, 120)        self.fc2 = nn.Linear(120, 84)        self.fc3 = nn.Linear(84, 10)    def forward(self, x):        # Max pooling over a (2, 2) window        x = F.max_pool2d(F.relu(self.conv1(x)), (2,2))        # If the size is a square you can only specify a single number        x = F.max_pool2d(F.relu(self.conv2(x)), 2)        x = x.view(-1, self.num_flat_features(x))        x = F.relu(self.fc1(x))        x = F.relu(self.fc2(x))        x = self.fc3(x)        return x    def num_flat_features(self, x):        size = x.size()[1:] # all dimensions except the batch dimension        num_features = 1        for s in size:            num_features *= s        return num_featuresnet = Net()print(net)</code></pre></li><li><p><strong>net.parameters()</strong>：返回可被学习的参数（权重）列表和值</p><pre class=" language-lang-python"><code class="language-lang-python">net = Net()params = list(net.parameters())print(len(params))print(params[0].size()) # conv1's .weight</code></pre></li><li><p><strong>n.functional</strong> ：除了nn别名以外，我们还引用了nn.functional，这个包中包含了神经网络中使用的一些常用函数，这些函数的特点是，不具有可学习的参数(如ReLU，pool，DropOut等)，这些函数可以放在构造函数中，也可以不放，但是这里建议不放。<code>import torch.nn.functional as F</code></p></li><li></li></ol><h2><span id="5-hua-tu-xiang-guan">5 画图相关</span><a href="#5-hua-tu-xiang-guan" class="header-anchor">#</a></h2><p><strong>头文件</strong>：</p><pre class=" language-lang-python"><code class="language-lang-python">from skimage import io, transform    #用于图像的IO和变换import matplotlib.pyplot as plt</code></pre><ol><li><p><strong>torchvision.utils.make_grid()</strong>：将若干幅图像拼成一幅图像。其中padding的作用就是子图像与子图像之间的pad有多宽。在需要展示一批数据时很有用</p></li><li><p><strong>plt.imshow(image)</strong>：展示一张图，<code>plt.imshow(np.transpose(npimg, (1, 2, 0)))</code>  在plt.imshow的输入的是（imagesize,imagesize,channels），img的格式为（channels,imagesize,imagesize）,这两者的格式不一致，需要转换后显示，原来的1换到0的位置，原来的2换到1的位置，原来的0换到最后。</p></li><li><p><strong>plt.ion()</strong>：interactive mode 在脚本中遇到plt.show()，代码还是会继续执行</p></li><li><p><strong>matplotlib.pyplot.scatter</strong>：散点图</p><pre class=" language-lang-python"><code class="language-lang-python">matplotlib.pyplot.scatter(x, y, s=None, c=None, marker=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, verts=None, edgecolors=None, *, data=None, **kwargs)# x，y：表示的是大小为(n,)的数组，也就是我们即将绘制散点图的数据点# s:是一个实数或者是一个数组大小为(n,)，这个是一个可选的参数。# c:表示的是颜色，也是一个可选项。默认是蓝色'b',表示的是标记的颜色，或者可以是一个表示颜色的字符，或者是一个长度为n的表示颜色的序列等等.# marker:表示的是标记的样式，默认的是'o'。</code></pre></li><li><p><strong>io.imread()</strong></p></li><li><p><strong>os.path.join()</strong>：<code>io.imread(os.path.join('data/faces/', img_name))</code></p></li><li><p><strong>fig = plt.figure()</strong>：一个画布</p></li><li><p><strong>ax = plt.subplot(1, 4, i + 1)</strong>：子图，1行，4列，这个是第i+1个</p></li><li><p><strong>ax.set_title</strong>(‘Sample #{}’.format(i))</p></li><li><p><strong>ax.axis(‘off’)</strong></p></li><li><p><strong>image = image.transpose((2, 0, 1))</strong>：交换颜色轴，因为numpy包的图片是: H <em> W </em> C，torch包的图片是: C <em> H </em> W</p></li><li><p><strong>plt.tight_layout()</strong>： 自动调整子图参数，使之填充整个图像区域</p><pre class=" language-lang-python"><code class="language-lang-python"># 并遍历数据样本。我们将会打印出前四个例子的尺寸并展示标注的特征点。face_dataset = FaceLandmarksDataset(csv_file='data/faces/face_landmarks.csv', root_dir='data/faces/')fig = plt.figure()for i in range(len(face_dataset)):    sample = face_dataset[i]    print(i, sample['image'].shape, sample['landmarks'].shape)    ax = plt.subplot(1, 4, i + 1)    plt.tight_layout()    ax.set_title('Sample #{}'.format(i))    ax.axis('off')    show_landmarks(**sample)    if i == 3:        plt.show()        break</code></pre></li></ol><h2><span id="mo-xing-xiang-guan">模型相关</span><a href="#mo-xing-xiang-guan" class="header-anchor">#</a></h2><ol><li><p><strong>保存加载整个模型</strong>：</p><pre class=" language-lang-python"><code class="language-lang-python"># save modeltorch.save(model,'mymodel.pkl')# load modelmodel=torch.load('mymodel.pkl')</code></pre></li><li><p><strong>仅保存加载模型参数（推荐）</strong>：相比较于保存整个模型而言，仅保存模型参数的做法应该不仅节省空间，更有灵活性的优势。可以取出特定层的参数，这一点在已经训练好的模型上取与现有模型相同层的参数上应该有帮助。</p><pre class=" language-lang-python"><code class="language-lang-python"># save model parameterstorch.save(model.state_dict(), 'mymodel.pkl')# load save model parametersmodel_object.load_state_dict(torch.load('mymodel.pkl'))</code></pre></li><li><p><strong>加载别的模型中相同的网络参数至新的模型</strong>：用已经训练好的网络参数作为自己模型的网络权重的初始化。下面代码实现了从<code>model_from</code>到<code>model to</code>的相同网络参数的拷贝。</p><pre class=" language-lang-python"><code class="language-lang-python">def transfer_weights(model_from, model_to):    wf = copy.deepcopy(model_from.state_dict()) # 对 model from中的模型参数的深度拷贝;    wt = model_to.state_dict() # 对 model to模型参数的获取    # 如果在model to中出现的网络结构，但是在model from中没有出现，那么就拷贝一份给wf。这样做的目的是让wf扩充后的结构跟wt一样，即保留了model from中的模型参数，又将结构扩充到跟 model to的一样    for k in wt.keys() :        if (not k in wf):                  wf[k] = wt[k]    model_to.load_state_dict(wf) # 通过load_state_dict函数加载我们想要的模型参数到目标模型model to中    # 以上的函数要求两个模型中如果具有相同的名字，那么对应的参数大小应该是一样的。</code></pre></li><li><p><a href="https://blog.csdn.net/u014380165/article/details/78525273">https://blog.csdn.net/u014380165/article/details/78525273</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch 及其应用</title>
      <link href="2020/04/21/pytorch/"/>
      <url>2020/04/21/pytorch/</url>
      
        <content type="html"><![CDATA[<h1><span id="pytorch-ji-qi-ying-yong">pytorch及其应用</span><a href="#pytorch-ji-qi-ying-yong" class="header-anchor">#</a></h1><p><strong>优点</strong>：</p><ol><li>支持GPU、灵活；</li><li>支持动态神经网络；</li><li>底层代码易于理解；</li><li>命令式体验；自定义扩展</li></ol><p><strong>缺点</strong>：</p><ol><li><p>对比TensorFlow，全面性不足，不支持快速傅里叶、沿维翻转张量和检查无穷与非数值张量；</p></li><li><p>针对移动端、嵌入式部署以及高性能服务器端的部署其性能表现有待提升；</p></li><li><p>因为框架较新，社区没有那么强大，在文档方面其C库大多数没有文档。</p><span id="more"></span></li></ol><h2><span id="huan-jing-pei-zhi">环境配置</span><a href="#huan-jing-pei-zhi" class="header-anchor">#</a></h2><ol><li>有关conda虚拟环境<pre><code>conda list # 查看安装了哪些包conda env list # 查看当前存在哪些虚拟环境conda update conda # 检查更新当前condapython --version # 查看python版本conda create -n xxx python=3.6 # xxx为自己命名的虚拟环境名称，该文件可在Anaconda安装目录 envs文件下找到conda create -n pytorch python=3.6conda activate yorr_env_name # 激活虚拟环境conda install -n your_env_name [package] # 对虚拟环境安装额外的包deactivate # 关闭虚拟环境conda remove -n your_env_name --allconda remove --name your_env_name package_name # 删除环境中的某个包</code></pre></li><li>虚拟环境下安装 jupyter</li></ol><pre><code>conda activate pytorchconda install nb_conda</code></pre><ol><li>pytorch安装<pre class=" language-lang-python"><code class="language-lang-python">conda activate pytorchconda install pytorch torchvision cpuonly -c pytorch</code></pre></li><li>离线安装（极其有用，血泪教训）<pre class=" language-lang-python"><code class="language-lang-python"># https://download.pytorch.org/whl/torch_stable.html# 下载对应的whl，然后安装pip install D:\software\Anaconda3\whl_download\torch-1.5.0+cpu-cp36-cp36m-win_amd64.whl</code></pre></li></ol><h2><span id="python-xue-xi-zhong-de-liang-da-fa-bao-han-shu">Python学习中的两大法宝函数</span><a href="#python-xue-xi-zhong-de-liang-da-fa-bao-han-shu" class="header-anchor">#</a></h2><ol><li><strong>dir() 道具</strong>：相当于你的手和眼睛，它可以帮你打开东西和看到其中的东西。能让你了解package有哪些东西，也许是更小的模块，或者是函数。dir() 函数，当输出是带有前后双下划线的，这个时候，就表明，这是一个函数，一个工具。你应该使用 help() 函数去查看这个工具的使用方法。</li><li><strong>help() 道具</strong>：相当于说明书，你可以知道每个工具的使用方法。能让你知道函数的使用方法。<pre class=" language-lang-python"><code class="language-lang-python">import torchdir(torch)help(torch.cuda.is_available)</code></pre></li></ol><h2><span id="shu-ju">数据</span><a href="#shu-ju" class="header-anchor">#</a></h2><pre class=" language-lang-python"><code class="language-lang-python">from PIL import Imageimg_path = "" # 注意，win下\\img = Image.open(ima_path)img.show()import osdir_path = "" # /img_path_list = os.listdir(dir_path) # 文件夹下的变成列表root_dir = "dataset/train"label_dir = "ants"path = os.path.join(root_dir,label_dir) # 系统自动加起来，不会出错</code></pre><pre class=" language-lang-python"><code class="language-lang-python">from torch.utils.data import Datasetclass MyData(Dataset):    def __init__(self, root_dir, label_dir):        self.root_dir = root_dir        self.label_dir = label_dir        self.path = os.path.join(self.root_dir,self.label_dir)        self.img_path = os.listdir(self.path) # 所有图片的名称    def __getitem__(self,idx):        img_name = self.img_path[idx] # 图片名        img_item_path = os.path.join(self.root_dir,self.label_dir, img_name) # 图片相对路径地址        img = Image.open(img_item_path) # 读取图片        label = self.label_dir # 这里label就是文件名        return img, label    def __len__(self):        return len(self.img_path) # 数据集的长度root_dir = "dataset/train"ants_label_dir = "ants"bees_label_dir = "bees"ants_dataset = MyData(root_dir, ants_label_dir)bees_dataset = MyData(root_dir, bees_label_dir)img, label = ants_dataset[0] # 就自动调用了__getitem__获取了第一个img.show()train_dataset = ants_dataset + bees_dataset # 合并数据集 数据增强</code></pre><h2><span id="gou-jian-zi-ji-de-wang-luo">构建自己的网络</span><a href="#gou-jian-zi-ji-de-wang-luo" class="header-anchor">#</a></h2><ol><li>处理数据</li><li>定义网络</li><li>定义损失函数</li><li>定义优化方法</li><li>训练</li></ol><p><strong>一个例子</strong>：</p><pre class=" language-lang-python"><code class="language-lang-python">import torchclass TwoLayerNet(torch.nn.Module):    def __init__(self, D_in, H, D_out):        """        在构造函数中，我们实例化了两个nn.Linear模块，并将它们作为成员变量。        """        super(TwoLayerNet, self).__init__()        self.linear1 = torch.nn.Linear(D_in, H)        self.linear2 = torch.nn.Linear(H, D_out)    def forward(self, x):        """        在前向传播的函数中，我们接收一个输入的张量，也必须返回一个输出张量。        我们可以使用构造函数中定义的模块以及张量上的任意的（可微分的）操作。        """        h_relu = self.linear1(x).clamp(min=0)        y_pred = self.linear2(h_relu)        return y_pred# N是批大小； D_in 是输入维度；# H 是隐藏层维度； D_out 是输出维度N, D_in, H, D_out = 64, 1000, 100, 10# 产生输入和输出的随机张量x = torch.randn(N, D_in)y = torch.randn(N, D_out)# 通过实例化上面定义的类来构建我们的模型。model = TwoLayerNet(D_in, H, D_out)# 构造损失函数和优化器。# SGD构造函数中对model.parameters()的调用，# 将包含模型的一部分，即两个nn.Linear模块的可学习参数。loss_fn = torch.nn.MSELoss(reduction='sum')optimizer = torch.optim.SGD(model.parameters(), lr=1e-4)for t in range(500):    # 前向传播：通过向模型传递x计算预测值y    y_pred = model(x)    #计算并输出loss    loss = loss_fn(y_pred, y)    # print(t, loss.item())    # 清零梯度，反向传播，更新权重    optimizer.zero_grad()    loss.backward()    optimizer.step()</code></pre><p>一个可以效仿的测试函数：</p><pre class=" language-lang-python"><code class="language-lang-python">def test(model, device, test_loader):    model.eval()    test_loss = 0    correct = 0    with torch.no_grad():        for i,data in enumerate(test_loader):                      x,y= data            x=x.to(device)            y=y.to(device)            optimizer.zero_grad()            y_hat = model(x)            test_loss += criterion(y_hat, y).item() # sum up batch loss            pred = y_hat.max(1, keepdim=True)[1] # get the index of the max log-probability            correct += pred.eq(y.view_as(pred)).sum().item()    test_loss /= len(test_loader.dataset)    print('\nTest set: Average loss: {:.4f}, Accuracy: {}/{} ({:.0f}%)\n'.format(        test_loss, correct, len(val_dataset),        100. * correct / len(val_dataset)))</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>A View of Cloud Computing</title>
      <link href="2020/04/20/cloud-compute/"/>
      <url>2020/04/20/cloud-compute/</url>
      
        <content type="html"><![CDATA[<h1><span id="shi-me-ni-huan-bu-zhi-dao-shi-me-shi-yun-ji-suan">什么？你还不知道什么是云计算</span><a href="#shi-me-ni-huan-bu-zhi-dao-shi-me-shi-yun-ji-suan" class="header-anchor">#</a></h1><h2><span id="qian-yan">前言</span><a href="#qian-yan" class="header-anchor">#</a></h2><p>随着疫情突如其来的到达，我们很多人都不得不在家中办公、学习，在这场疫情中，很多线下实体商业受到了巨大的冲击，很多小公司支撑不住，面临倒闭的危险。然后，很多互联网企业却在其中赚的盆满钵满。</p><p>学生们通过慕课平台在线观看老师的教学；公司通过远程会议软件实行远程办公；为了避免交叉感染各大医院纷纷推出了线上看诊、在线预约；娱乐行业中，各大综艺纷纷采取“云录制”的形式，最大程度避免了人员接触……，还有许许多多这样的例子，虽然这些服务各不相同，但是其背后都需要依赖庞大的计算资源和网络带宽，而云计算作为互联网的基础服务在这场疫情之中就扮演了最重要的角色，在互联网世界中，云计算就和水、电一样重要。</p><span id="more"></span><h2><span id="yi-guan-yu-yun-ji-suan-ni-ying-gai-liao-jie-zhe-xie">一、关于云计算你应该了解这些</span><a href="#yi-guan-yu-yun-ji-suan-ni-ying-gai-liao-jie-zhe-xie" class="header-anchor">#</a></h2><ol><li><strong>云计算</strong>：既指通过互联网提供服务的应用程序，所谓软件即服务（SaaS）中的服务，也指提供这些服务的数据中心的硬件和系统软件 。</li><li><strong>cloud</strong>：数据中心的软硬件，称作云。</li><li><strong>public cloud</strong>：当一个云面向公众，以<strong>用即付费</strong>（pay-as-you-go）的方式提供时，我们称之为公有云，提供效用计算（Utility Computing）服务。</li><li><strong>utility computing</strong>：服务被销售则称效用计算，是一种服务预配模型，服务提供商按需向客户提供计算资源和基础设施管理，并且按使用情况而不是按统一费率计费。</li><li><strong>private cloud</strong>：公众无法使用的企业/组织内部的数据中心称为私有云。</li><li><strong>cloud computing</strong>：云计算是SaaS和utility computing之和，但不包括私有云。</li><li>对应到用户角色上，关系如下图，SaaS providers 同时也可以是 SaaS users。</li></ol><p><img src="/2020/04/20/cloud-compute/a.png" alt="a" style="zoom:80%;"></p><h2><span id="er-wei-shi-me-yun-ji-suan-ke-yi-yin-fa-bian-ge">二、为什么云计算可以引发变革</span><a href="#er-wei-shi-me-yun-ji-suan-ke-yi-yin-fa-bian-ge" class="header-anchor">#</a></h2><ol><li><p><strong>从硬件和定价角度来说，云计算带来的变化在于</strong>：</p><ul><li>能按需提供无限的计算资源；</li><li>云用户无需预估资源；</li><li>支持即用即付的短期计算资源。能根据需要对计算资源的短期使用付费（如按小时计的处理器，按天计的存储等），并在需要时发布，这样可以在它们不再有用的时候释放机器和存储资源。</li></ul></li><li><p><strong>云计算的关键优势在于资源弹性调配</strong>（elasticity of resources），1000 台服务器用 1 小时的成本不超过 1 台服务器用 1000 小时，这种资源上的弹性是前所未有的：</p></li><li>云计算还让应用程序提供者能够<strong>将其产品作为 SaaS 部署，而无需拥有自己的数据中心</strong></li><li>正如 SaaS 允许用户将一部分问题抛给 SaaS 服务提供商，云计算允许 SaaS 服务提供商将一些问题丢给云计算供应商</li><li><strong>云计算的一个成功关键</strong>：在低成本地点建设和运营超大规模的商用计算机数据中心，在这些非常大的经济规模下，使可用的电力、网络带宽、操作、软件和硬件成本可以降低5%到7%。与多路复用结合后可进一步提高利用率，意味着云计算可以以低于中型数据中心的成本提供服务，同时仍能获得丰厚的利润。</li></ol><h2><span id="san-xiao-yong-ji-suan-de-lei-bie">三、效用计算的类别</span><a href="#san-xiao-yong-ji-suan-de-lei-bie" class="header-anchor">#</a></h2><p>不同的效用计算产品可以根据提供给开发者的<strong>抽象层级和资源管理级别</strong>来区分。例如，当时的几种云产品都对计算、存储和网络等资源进行了不同程度的虚拟化：</p><ol><li>Amazon EC2：是这个领域的一端。提供云虚机，像物理硬件一样，用户能够控制整个资源栈。这种低层次对于Amazon来说，使得提供自动可扩展和失效处理本质上很难，因为与复制和其他状态管理问题相关的语义是高度依赖于应用的。</li><li>Google AppEngine：另一个极端是特定于应用程序领域的平台，提供面向应用程序的运行环境，如Google AppEngine。AppEngine 具有优秀的自动扩展和高可用机制的特点，及AppEngine应用可用的适当的MegaStore数据存储。</li><li>Microsoft的Azure：提供.NET 运行环境，介于前两者之间。该框架比AppEngine的框架灵活得多，但仍然限制了用户对存储模型和应用程序结构的选择，Azure 介于AppEngine等应用程序框架和EC2等硬件虚拟机之间。</li></ol><p>但从云供应商和云用户的角度来看，这几种效用计算产品只是在开发者易用性、灵活性和可移植性之间的权衡，各自有其不同的适用场景。</p><h2><span id="si-yun-ji-suan-dai-lai-liao-na-xie-jing-ji-shang-de-you-shi">四、云计算带来了哪些经济上的优势</span><a href="#si-yun-ji-suan-dai-lai-liao-na-xie-jing-ji-shang-de-you-shi" class="header-anchor">#</a></h2><h3><span id="guan-kui-dian-xing-de-xiao-yong-ji-suan-you-yu-si-you-yun-de-chang-jing">① 管窥：典型的，效用计算优于私有云的场景：</span><a href="#guan-kui-dian-xing-de-xiao-yong-ji-suan-you-yu-si-you-yun-de-chang-jing" class="header-anchor">#</a></h3><ol><li><strong>当对服务的需求随时间变化的时候</strong>。例如，数据中心每月必须维持的几天高峰负载调配资源，而其他时间利用率不足。云计算让该组织可以按小时支付计算资源费用，即使从云提供商那里租用机器的每小时费率高于拥有一台机器的每小时费率，也可能导致成本节约。</li><li><strong>当事先不知道需求的时候</strong>。例如，一家网络初创公司在变得受欢迎时将需要支持需求的激增，随后可能会在一些访问者离开时支持需求的减少。</li><li><strong>执行批量分析的组织可以使用云计算的“成本关联性”更快地完成计算</strong>。例如：使用1，000台EC2机器1小时的成本与使用1台机器1，000小时的成本相同。</li></ol><h3><span id="wei-shi-me-dan-xing-he-feng-xian-zhuan-yi-ke-yi-dai-lai-ji-qi-chong-yao-de-yun-ji-suan-jing-ji-xiao-yi">② 为什么弹性和风险转移，可以带来极其重要的云计算经济效益</span><a href="#wei-shi-me-dan-xing-he-feng-xian-zhuan-yi-ke-yi-dai-lai-ji-qi-chong-yao-de-yun-ji-suan-jing-ji-xiao-yi" class="header-anchor">#</a></h3><ol><li><p>在弹性方面，<strong>云计算能够以细粒度</strong>（使用EC2，一次添加或删除一台服务器）<strong>添加或删除资源</strong>，并且<strong>提前期为几分钟</strong>而不是几周，这使得<strong>资源与工作负载的匹配更加紧密</strong>。</p><ul><li><p>弹性的好处可以在很多方面体现出来，因为除了简单的日间模式外，大多数服务还会经历季节性或其他周期性的需求变化。（例如，12月份的电子商务和节后的照片分享网站)以及一些因外部事件（例如新闻事件）而导致的意想不到的需求爆发。</p></li><li><p>由于获取和安装新设备可能需要数周时间，因此要处理此类峰值，必须提前做好准备。可以看到，即使服务运营商正确预测峰值大小，容量也是浪费的，如果他们高估了他们准备的峰值，情况会更糟。</p></li><li><p>与过度配置的成本浪费相比，<strong>配置不足的成本难易衡量且更加严重</strong>：被拒绝的用户不仅产生零收入，而且可能永远不会回来。eg：竞争对手Facebook和MySpace相比，Friendster人气下降的部分原因被认为是用户对缓慢的响应时间（长达40秒）的不满。</p></li></ul></li><li><p>因此，<strong>伸缩的弹性</strong>不是成本优化，而<strong>是运营要求</strong>。</p></li></ol><h2><span id="wu-yun-ji-suan-mian-lin-de-shi-da-zhang-ai-he-ji-yu">五、云计算面临的十大障碍和机遇</span><a href="#wu-yun-ji-suan-mian-lin-de-shi-da-zhang-ai-he-ji-yu" class="header-anchor">#</a></h2><h3><span id="1-ye-wu-lian-xu-xing-he-fu-wu-ke-yong-xing">1  业务连续性和服务可用性</span><a href="#1-ye-wu-lian-xu-xing-he-fu-wu-ke-yong-xing" class="header-anchor">#</a></h3><ol><li><p><strong>效用计算服务是否有足够的可用性？</strong>这让一些人对云计算保持警惕。现有的SaaS产品在这方面设定了很高的标准（比如谷歌搜索以高度可用性著称），用户希望从新服务中获得类似的可用性，这是很难做到的。</p><ul><li><p>撇开技术可用性问题不谈，云提供商可能会因为非技术原因而遭受停机，包括停业或成为监管行动的目标（比如 2009年3月，联邦调查局突袭了达拉斯的一个数据中心，因为在那里托管服务的一家公司正在接受可能的犯罪活动调查，但在同一设施中托管的一些“无辜的旁观者”公司遭受了数天的意外停机，其中一些公司倒闭了）</p></li><li><p>尽管云供应商可以提供专门的硬件和软件技术，以提供更高的可靠性，估计价格会很高。然后，这种可靠性可以作为服务级别协议出售给用户，但这种方法只能走到这一步，并不长远。</p></li></ul></li><li><strong>单点故障？</strong>高可用性计算社区长期以来一直遵循“没有单点故障”的信条，然而，由一家公司管理云计算服务实际上是一个单点故障。（极端情况：该公司可能会倒闭！）。因此，在这种情况下，如果没有业务连续性策略，大客户将不愿迁移到云计算</li><li><strong>机会</strong>：因为一家公司很难证明以软件可靠性的名义创建和维护两个堆栈是合理的，实现非常高可用性的唯一可能的解决方案是<strong>多个云计算提供商</strong>。</li></ol><h3><span id="2-data-lock-in-shu-ju-suo-ding">2 Data Lock-in 数据锁定</span><a href="#2-data-lock-in-shu-ju-suo-ding" class="header-anchor">#</a></h3><ol><li><strong>数据锁定？</strong>云计算的存储API本质上仍然是专有的，或者至少没有成为活跃的标准化的主题。因此，客户不能轻松地将其数据和程序从一个站点提取到另一个站点上运行，从云中提取数据的困难阻碍了一些组织采用云计算。</li><li><strong>机会</strong>：将 APIs 标准化，这样SaaS开发人员可以跨多个云计算提供商部署服务和数据，这样一家公司的失败就不会带走客户数据的所有副本。<strong>可能导致云计算定价的“逐底竞赛”，并使云计算提供商的利润变得扁平？No</strong><ul><li>首先，<strong>服务的质量和价格都很重要</strong>。今天，一些互联网服务提供商的价格比其他提供商高出10倍，因为他们更可靠，并提供额外的服务来提高可用性。</li><li>其次，除了缓解数据锁定问题外，API标准化使得可以在内部数据中心和公共云中使用相同的软件基础设施（因为API相同）。这样就可以<strong>实现混合云计算或 surge computing</strong>，使用公共云来捕获无法在私有云中轻松运行的额外任务。</li></ul></li></ol><h3><span id="3-data-confidentiality-auditability-shu-ju-ji-mi-xing-ke-shen-he-xing">3 Data  Confidentiality/Auditability 数据机密性/可审核性</span><a href="#3-data-confidentiality-auditability-shu-ju-ji-mi-xing-ke-shen-he-xing" class="header-anchor">#</a></h3><ol><li><p><strong>云用户面临来自云外部和云内部的安全威胁？</strong></p><ul><li>保护云免受<strong>外部威胁</strong>所涉及的许多安全问题与大型数据中心已经面临的问题类似。在云中，这一责任在潜在的多方之间分配，包括云用户、云供应商以及用户依赖于安全敏感软件或配置的任何第三方供应商。</li><li>云计算还带来了<strong>面向内部的安全的新问题</strong>。云提供商必须防范用户的盗窃或拒绝服务攻击。用户之间需要相互保护。</li></ul></li><li><p><strong>机会</strong>：当今云中的主要安全机制是虚拟化。这是一种强大的防御措施，可抵御用户互相攻击或攻击底层云基础设施的大多数企图，但是，并不是所有的资源都是虚拟化的，也不是所有的虚拟化环境都是没有错误的。</p></li><li><p><strong>保护云用户免受提供商的攻击？</strong>提供商将控制软件堆栈的“底层”，这有效地规避了大多数已知的安全技术，需要防范提供商的渎职行为。比如，很容易想象硬盘在没有被擦除的情况下被处理，或者权限错误使数据不正确地可见。</p></li><li><p><strong>机会</strong>：标准防御，即用户级加密。这在非云环境中这已经很常见了，而且工具和专业知识都很容易获得。</p></li></ol><h3><span id="4-data-transfer-bottlenecks-shu-ju-chuan-shu-ping-jing">4 Data transfer Bottlenecks 数据传输瓶颈</span><a href="#4-data-transfer-bottlenecks-shu-ju-chuan-shu-ping-jing" class="header-anchor">#</a></h3><ol><li><strong>数据传输成本？</strong>应用程序继续变得更加数据密集型，可能会使数据放置和传输变得复杂。</li><li><strong>机会</strong>：运送磁盘 ，Jim Gray发现，发送大量数据最便宜的方式是运送磁盘甚至整台计算机。</li></ol><h3><span id="5-performance-unpredictability-xing-neng-bu-ke-yu-ce">5 Performance unpredictability 性能不可预测</span><a href="#5-performance-unpredictability-xing-neng-bu-ke-yu-ce" class="header-anchor">#</a></h3><ol><li><strong>I/O干扰？</strong>在云计算中，多个虚拟机可以很好地共享CPU和主存，但网络和磁盘I/O共享（虚拟机之间的I/O干扰）成为了主要的问题。</li><li><strong>机会</strong>： flash memory 将减少I/O干扰。闪存是一种半导体存储器，可以像机械硬盘一样在断电时保存信息，但由于它没有移动部件，访问速度要快得多，而且能耗更低。</li><li><strong>虚拟机调度？</strong>许多HPC应用程序需要确保程序的所有线程同时运行，而今天的虚拟机和操作系统没有提供程序员可见的方式来确保这一点。</li><li><strong>机会</strong>：为云计算提供类似于“团队调度”的东西。但是在云计算环境中，传统团队调度中预期的相对紧密的定时协调可能很难实现。</li></ol><h3><span id="6-scalable-storage-ke-kuo-zhan-cun-chu">6  Scalable Storage 可扩展存储</span><a href="#6-scalable-storage-ke-kuo-zhan-cun-chu" class="header-anchor">#</a></h3><ol><li><strong>持久存储？</strong>我们确定了云计算十分吸引人的三个属性：短期使用量，没有前期成本，以及按需提供无限容量。虽然这在应用于计算时意味着什么是直截了当的，但如何将其应用于持久存储就不那么清楚了。</li><li><strong>机会</strong>：创建一种存储系统，它不仅要满足程序员在耐用性、高可用性以及管理和查询数据的能力方面的现有期望，而且要将它们与按需任意上下扩展的云优势结合起来。</li></ol><h3><span id="7-bugs-in-large-scale-distributed-systems-da-gui-mo-fen-bu-shi-xi-tong-zhong-de-cuo-wu">7 Bugs in Large-Scale Distributed Systems 大规模分布式系统中的错误</span><a href="#7-bugs-in-large-scale-distributed-systems-da-gui-mo-fen-bu-shi-xi-tong-zhong-de-cuo-wu" class="header-anchor">#</a></h3><ol><li><strong>消除这些超大规模分布式系统中的错误？</strong>常见的情况是，这些错误不能在较小的配置中重现，因此调试必须在生产数据中心大规模进行。</li><li><strong>机会</strong>：发明适用于分布式虚拟机的调试器。</li></ol><h3><span id="8-scaling-quickly-kuai-su-tuo-zhan">8 Scaling Quickly 快速拓展</span><a href="#8-scaling-quickly-kuai-su-tuo-zhan" class="header-anchor">#</a></h3><ol><li><strong>计算方式不同？</strong>现收现付适用于存储和网络带宽，但是根据虚拟化级别的不同，计算略有不同。比如：Google AppEngine会根据负载的增加和减少自动进行扩展，并根据使用的周期向用户收费。AWS按占用的实例数按小时收费，即使计算机处于空闲状态。</li><li><strong>机会</strong>：发明基于机器学习的自动扩展机制，自动根据负载快速扩展和缩减，以节省资金。</li><li><strong>节约资源？</strong>由于一台空闲的计算机使用的功率大约是一台繁忙计算机的三分之二，因此谨慎使用资源可以减少数据中心对环境的影响，而数据中心对环境的影响正受到极大的负面关注。</li><li><strong>机会</strong>：云计算提供商对资源消耗进行仔细且低开销的核算、使用快速且易于使用的快照/重启工具。</li></ol><h3><span id="9-reputation-fate-sharing-sheng-yu-ming-yun-gong-xiang">9 Reputation fate Sharing 声誉命运共享</span><a href="#9-reputation-fate-sharing-sheng-yu-ming-yun-gong-xiang" class="header-anchor">#</a></h3><ol><li><strong>声誉共享？</strong>一个客户的不良行为可能会影响使用同一云的其他客户的声誉。</li><li><strong>机会</strong>：创建类似于目前向小型ISP托管的服务提供（收费）的“可信电子邮件”服务的声誉保护服务。</li></ol><h3><span id="10-software-licensing-ruan-jian-xu-ke">10  Software Licensing 软件许可</span><a href="#10-software-licensing-ruan-jian-xu-ke" class="header-anchor">#</a></h3><ol><li><strong>商业软件的许可模式与效用计算不匹配？</strong>当前的软件许可证通常会限制可以在其上运行该软件的计算机。用户先支付软件费用，然后每年支付维护费。</li><li><strong>机会</strong>：主要的机会要么是让开源保持流行，要么只是让商业软件公司改变他们的许可结构（即提供即付即用软件许可），以更好地适应云计算。</li></ol><p><strong>总结：</strong></p><p><img src="/2020/04/20/cloud-compute/b.png" alt="b" style="zoom:80%;"></p><p>P.S.前三个是采用云计算的技术阻碍，中间五个是云计算发展的技术阻碍，最后两个是采用云计算的政策和业务阻碍，右侧对应的机会是预期的解决方案。</p><h2><span id="liu-yun-ying-yong-kai-fa-ke-neng-yu-dao-na-xie-kun-nan">六、云应用开发可能遇到哪些困难？</span><a href="#liu-yun-ying-yong-kai-fa-ke-neng-yu-dao-na-xie-kun-nan" class="header-anchor">#</a></h2><ol><li>应用程序可能在云环境中无法发挥理想的作用，可能涵盖一些难易处理的规则限制等。</li><li>云计算相关教材说明还很匮乏，阻碍很多开发人员研究云技术。</li><li>在云环境中运行容易造成“资源浪费”，开发人员很容易忘记或者忽视应该把不使用的虚拟机关闭。如果是企业内部部署的私有服务器，只会损失一些电费而已，但是如果使用计时租赁的公有云服务，会造成更大的浪费。</li><li>如果在云端存储重要的信息，因为云服务器很可能有突发情况的产生，所以一定要确保有一份备份，要保证备份数据的更新，定期测试备份数据的完整性，同时这些备份要存储在一个云服务器不同的位置。</li><li>对于预算充足的开发人员，为了实现高可用性，最好同时使用一家以上的云服务提供商，当然，这也会造成金钱的浪费。</li></ol><h2><span id="qi-ru-guo-mei-you-yun-ji-suan">七、如果没有云计算！</span><a href="#qi-ru-guo-mei-you-yun-ji-suan" class="header-anchor">#</a></h2><p>通过上面的描述，我们知道云计算时代已经来临，云供应商能够以即用即付的模式销售所拥有的的计算资源，通过资源复用来获利。云用户能够节省建立自己数据中心的高额成本，同时从资源预配风险中解脱出来。</p><p>从正式的角度看，<strong>假设我们没有了云计算，那么会发生什么呢？</strong></p><ul><li><strong>硬件成本高</strong>：一台服务器成本高达几万元加上托管费和网络费用等等，一些中小企业承受不起如此昂贵的支出，在市场波动中，轻易的丧失了存活的资本。</li><li><strong>利用率低</strong>：一台服务器如果只运行一个服务，可能资源利用率不到 10%，但是如果把很多服务都跑在同一台服务器上，虽然可以提升服务器的资源利用率，但是一旦服务器出现故障，所有的进程都会挂掉，缺乏高可用能力。</li><li><strong>可扩展性低</strong>：维护成本过高，一台服务器要升级硬件是非常的耗费人力和时间的，可以想象如果一台服务器出现硬件故障或要增加磁盘，运维人员需要从公司跑到机房去升级硬件，这中间需要停机断电升级。后来一些服务器进行升级支持热插拔技术，但是也还是需要有人去机房升级或者有的机房，这种方式的可扩展性和维护成本之高是一些中小企业无法承受的。</li></ul><p><strong>非正式的角度呢？</strong></p><ul><li><strong>阿里巴巴会破产</strong>：马云曾公开发表演讲，如果阿里巴巴没有支持对云计算的研究，那么阿里巴巴最终会因为支付不起IBM和甲骨文的高额服务而破产，云计算的发展，造福了千万的小公司。</li><li><strong>没有双十一的盛况</strong>：没有了云计算，消费者的购物体验会大打折扣，人稍微一多点，系统就卡顿，零点集中疯抢更是难以想象。2018年的天猫双11，人们在感叹云计算支撑起了32.5万/秒的交易峰值，以及25.6万/秒的支付峰值；在2019年的天猫双11，阿里云更是支撑住了每秒订单创建峰值49.1万笔的超强挑战！</li></ul><p><strong>还有一些有意思的场景</strong>：</p><p><img src="/2020/04/20/cloud-compute/c.jpg" alt="c" style="zoom:80%;"></p><p>没有了高性价比的云存储和CDN服务，Mybnb无法在自己的官方网站和App中为房东提供足够的存储空间，来展示他们精美的房屋照片。但为了吸引用户们预订房屋，Mybnb不得不组建线下地推团队，将房屋照片印制成画册，在人流密集的地方，向客户们推广！</p><p><img src="/2020/04/20/cloud-compute/d.jpg" alt="d" style="zoom:80%;"></p><p>地推团队辛勤劳动带来的订单成为了后端噩梦…面对新订单斩钉截铁的说：<strong>“我们是初创公司！没有云计算，每天只能处理100个订单！！！”</strong></p><p><img src="/2020/04/20/cloud-compute/e.jpg" alt="e" style="zoom:80%;"></p><p>非常优秀的机器视觉服务已经无法负担海量的访问需求了，不得已只能采取另一种“人工智能”。</p><p><img src="/2020/04/20/cloud-compute/f.jpg" alt="f" style="zoom:80%;"></p><p>乘坐“无人驾驶”汽车上五环再也不用担心了，“无人驾驶”合法化指日可待。</p><p><img src="/2020/04/20/cloud-compute/g.jpg" alt="g" style="zoom:80%;"></p><p>云计算消失之后，大数据行业慢慢从技术密集型向劳动密集型靠拢</p><h2><span id="ba-zui-hou">八、最后</span><a href="#ba-zui-hou" class="header-anchor">#</a></h2><p>“如果云计算是一个罐头，我希望它永远都存在，如果一定要加上一个期限的话，我希望是一万年。”</p><h2><span id="can-kao-zi-liao">参考资料</span><a href="#can-kao-zi-liao" class="header-anchor">#</a></h2><p>[1] Above the Clouds: A Berkeley View of Cloud Computing</p><p>[2] <a href="https://zhuanlan.zhihu.com/p/27926289">如果没有云计算，这个世界会怎么样</a></p>]]></content>
      
      
      <categories>
          
          <category> paper-cv </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>build a wonderful world</title>
      <link href="2020/04/18/world/"/>
      <url>2020/04/18/world/</url>
      
        <content type="html"><![CDATA[<h1><span id="ke-xue-ji-zhu-dao-di-ke-yi-wei-wo-men-dai-lai-shi-me">科学技术到底可以为我们带来什么</span><a href="#ke-xue-ji-zhu-dao-di-ke-yi-wei-wo-men-dai-lai-shi-me" class="header-anchor">#</a></h1><p>这是本篇文章的主题：社会企业家朱莉·科杜瓦（Julie Cordua）致力于解决一个“难以启齿”的问题：互联网上以图片和视频形式存在的儿童性侵。</p><h3><span id="chi-wo-hen-yuan-ba">离我很远吧</span><a href="#chi-wo-hen-yuan-ba" class="header-anchor">#</a></h3><p>Ted talk video的开始，首先映入眼帘的就是纯白色的背景，大大的字写着，“涉及成人话题”，在高科技术快速发达的今天，我们所有人无一不在享受着互联网技术带来的便利，最近出现的“星星”事件，我大胆猜测，虽然引起了人们的注意，但恐怕大多数人也只是和最开始的我抱着相同的心理，“竟然有这样的人”，“要制裁他”，但每个人心中也都有想，“这应该离我很远吧”。</p><span id="more"></span><h3><span id="nei-rong-ji-huo-bi">内容即货币</span><a href="#nei-rong-ji-huo-bi" class="header-anchor">#</a></h3><p>video中谈到，在刚刚过去的2019年，仅在美国，就仅在美国就有超过4500万涉及儿童性侵的图像和视频内容被举报至国家失踪与受虐儿童中心，比2018年翻了翻。更是难以想象这些数字背后的细节真相： 超过60%的图像拍摄的是不到12岁的孩子， 而且大多包含极端性暴力行为。 虐待者在专门讨论虐待儿童的聊天室里颇受欢迎， 随着更强的侵犯和更多受害者的出现， 他们在那里的排名和地位就更高。 </p><p>有一句话说的很对，它们的世界中，内容就是货币。它们快速掌握日渐更新的新技术，不断的加害于还没有认识清这个世界的孩子。 我们作为一个社会整体的回应却严重滞后。那些施暴者不分国界，甚至不分性别，在全世界各大品台中流动，而我们的执法工作仅在一个司法管辖区进行， 每一个企业只专注于他们自己的平台， 无利益即无关的想法使得他们之间很少沟通。</p><h3><span id="suo-en-de-xing-dong">索恩的行动</span><a href="#suo-en-de-xing-dong" class="header-anchor">#</a></h3><p>在索恩（Thorn）公司，她们的行动分为两步，联系执法机构政府，以更快的帮助孩子被解救；同时联系各大视频网站，通过使用她们的软件检测哪些涉及儿童性侵的图像和视频，报告给执法机构。</p><p>她们使用的技术是获取已经发现的在互联网传播的受害者视频，获得哈希值，利用哈希值唯一性，去检索各大网站的数据库，如果比对发现哈希值相同，移除内容， 并且将其报告给国家失踪与受虐儿童中心， 然后那些哈希再返回到她们的系统， 令每个使用该软件的企业都可以有更多的哈希值以比较。 当数百万的哈希值指向更多内容时， 全世界的企业就能实时识别并移除数百万的内容， 从全球的网络上移除儿童性侵媒体内容的速度将会大大提升。</p><p>例如，她们第一个合作伙伴，Imgur，每天有用户生产 的数百万内容被上传， 在开始使用系统的20分钟内， 有人尝试上传一个已知的儿童性侵内容。 Imgur因此能够及时阻止，移除内容， 并向国家失踪与受虐儿童中心报告。 他们更进一步， 找到并审查了内容发布人的账号， 却发现了其他上百个没看过的儿童性侵媒体内容。</p><h3><span id="together">Together</span><a href="#together" class="header-anchor">#</a></h3><p>很明显，如果需要构建这样的系统，必须拥有足够多的视频哈希值，不断扩充数据库，来更有效的组织视频的传播和散布。这也是这次ted演讲的目的，动员世界范围内数千名警官， 以及数百家企业。 </p><p>第一代受到侵犯的媒体资料被大肆传播的孩子们已经长大成人。加拿大儿童保护中心最近针对这些年轻人做了一个研究， 80%有过自杀的想法， 超过60%曾尝试自杀。 他们的大部分人每天都生活在恐惧中： 当他们走上街头， 或参加一个面试， 或是去学校， 或是在网上碰见的某个人，有超过30%人， 噩梦成为现实， 他们因为网上性侵的内容被认出。</p><p><strong>这条路不简单， 但并不是不可能</strong>。 现在需要展现我们社会的决心， 去着手解决非常难以直面的问题， 在黑暗中创造希望， 让那些孩子的声音能被听见； 去展现企业们的决心，采取一切措施并确保他们的平台不与儿童侵犯者共谋； 去展现政府部门的决心， 投资执法部门破案设施， 来调查数字先行的犯罪， 即便受害者无法为自己申辩。 </p><blockquote><p>作为一名有机会帮助到打击数字先行犯罪的人，希望未来我的研究可以做些什么，可以不仅仅是靠一个个的哈希值的比对，人为的加入数据库。</p></blockquote><h3><span id="in-a-future-every-child-can-simply-be-a-kid">In a future，every child can simply be a kid</span><a href="#in-a-future-every-child-can-simply-be-a-kid" class="header-anchor">#</a></h3><p><img src="/2020/04/18/world/a.png" alt="a"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Attribute-aware Pedestrian Image Editing</title>
      <link href="2020/04/16/apie/"/>
      <url>2020/04/16/apie/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#qian-yan">前言</a></li><li><a href="#fang-fa">方法</a><ul><li><a href="#0-jia-gou-tu-4-bu-fen">0 架构图（4部分）</a></li><li><a href="#1-attribute-aware-segmentation-network">1 Attribute-aware Segmentation Network</a></li><li><a href="#2-the-generator">2 The Generator</a><ul><li><a href="#2-1-encoder-decoder-network-with-skip-connection">2.1 Encoder-decoder network with skip connection</a></li><li><a href="#2-2-discrimination-between-latent-variables">2.2 Discrimination between latent variables</a></li></ul></li><li><a href="#3-the-multi-scale-discriminators">3 The Multi-scale Discriminators</a></li><li><a href="#4-the-attribute-classifier">4 The Attribute Classifier</a></li><li><a href="#5-the-overall-loss">5 The Overall Loss</a></li></ul></li><li><a href="#shi-yan">实验</a><ul><li><a href="#3-1-datasets-and-implementation">3.1 Datasets and implementation</a></li><li><a href="#3-2-pedestrian-image-editing">3.2 Pedestrian Image Editing</a></li><li><a href="#3-3-person-re-id-and-attribute-prediction-de-shu-ju-zeng-qiang">3.3 Person Re-ID and Attribute Prediction 的数据增强</a></li><li><a href="#3-4-ablation-study">3.4 Ablation Study</a></li></ul></li><li><a href="#zong-jie">总结</a></li><li><a href="#wo-de-si-kao">我的思考</a></li></ul><!-- tocstop --></div><p>[TOC]</p><blockquote><p>关于论文《Attribute-aware Pedestrian Image Editing》，from 孙晓洁</p></blockquote><h1><span id="qian-yan">前言</span><a href="#qian-yan" class="header-anchor">#</a></h1><ol><li><strong>任务</strong>：行人图像生成  Pedestrian image generation </li><li><strong>难点</strong>：<ul><li><strong>现存生成方法不足</strong>：身体变形 body distortion（身体部分位置错乱）、视觉细节不足 inadequate visual details、模糊区域较大 large vague areas（due to：不确定视角的不同外观和复杂背景场景） 。</li><li><strong>行人图像生成</strong>：相比一般的图像生成，行人图像生成更具挑战，因为由于复杂的身体形态和姿势，丰富的细节，多种多样的灯光和背景。</li></ul></li><li><strong>提出架构</strong>：<strong>Attribute-aware Pedestrian Image Editing (APIE)</strong> ；<strong>APIE-Net</strong><ul><li><strong>an attribute-aware segmentation network</strong>：希望避免行人外观的动态扰动，使用segmentation network来定位感兴趣的region，以将generation集中在我们目标的body part上，排除其他region或者background的影响。</li><li><strong>a multi-scale discriminator</strong>：希望生成更多的视觉细节，使用多尺度对抗判别器来捕获不同粒度的局部视觉信息。</li><li><strong>a latent-variable discriminator</strong>：希望分离彼此混合或者和其他 image appearance 混合的属性，使用潜层变量的对抗性训练来去除不相关的属性或者image region的副作用，例如，对于白色和条纹布，我们希望在切换颜色的同时保留条带。</li></ul></li><li><strong>目标</strong>：<ul><li>因为 <strong>视觉属性 Visual attributes</strong> 通常描述了特定区域，比如“上身黑”是指上半身的像素，视觉属性相对一致，并且对于视点和背景是不变的，所以我们关注更一般的<strong>基于视觉属性的行人生成</strong> general attribute-based pedestrian generation</li><li>对于某个特定的视觉属性，我们的目标是重新生成（或编辑）具有该视觉属性的特定行人的图像。</li></ul></li><li><strong>作用</strong>：<ul><li>APIE-Net能够生成具有给定属性的令人满意的行人图像</li><li>生成的图像可以对原始数据集进行扩充 增强 data augmentation of pedestrian image datasets，从而提高了行人识别(Re-ID)和属性预测 person attribute prediction 等与行人相关的任务的性能 。</li></ul></li></ol><h1><span id="fang-fa">方法</span><a href="#fang-fa" class="header-anchor">#</a></h1><h2><span id="0-jia-gou-tu-4-bu-fen">0 架构图（4部分）</span><a href="#0-jia-gou-tu-4-bu-fen" class="header-anchor">#</a></h2><p><img src="/2020/04/16/apie/a.png" alt="architecture image" style="zoom: 67%;"></p><ol><li><strong>输入端</strong>： an attribute-aware segmentation network，用于分割给定的行人图像，提取给定属性我们感兴趣的对应区域。</li><li><strong>Generator</strong>：由具有skip connections的 encoder-decoder network 和用于删除相互矛盾的属性的 latent-variable discriminator 组成。</li><li><strong>Multi-scale discriminator</strong>：保证了生成图像的真实性。</li><li><strong>Attribute classifier</strong>：确保生成的图像拥有我们之前给定的属性。</li></ol><p>$ x_a $ 表示输入图像，$\Bbb x \in R^{W×H×C} $ （$W$ $H$ $C$ 分别代表width，height，channel的数量），同时这个图像拥有属性$a \in \{0,1\}^l$（$a$是一个vector）， $l$ 表示属性 类别的数量。比如，如果$a$的第$t$个分量是$1$，也就意味着$x_a$拥有第$t$个属性（e.g. 白色的上衣），没有这个属性的话就是$0$。APIE-NET的整体目标是生成一个拥有属性$b$ 的新的行人图像$x_b$（e.g. 蓝色的上衣）。</p><h2><span id="1-attribute-aware-segmentation-network">1 Attribute-aware Segmentation Network</span><a href="#1-attribute-aware-segmentation-network" class="header-anchor">#</a></h2><p><strong>获取mask</strong></p><p>为了根据我们指定要改变的属性决定其在body part中的位置，我们提出了 attribute-aware pedestrian segmentation （基于属性感知的行人分割），我们采用了一个已经 well-trained segmentation model ，基于fine-grained 的分割结果，结合使用者指定的特定目标，我们可以获得 mask，$ m_a\in \{0,1\}^{W×H} $，其中 pixels 的值为 1 代表着属于前景foreground area，0 代表属于背景 background area.</p><p><strong>注意</strong>，如果行人身体的关键点可用，我们也可以利用pose 姿势信息来获得mask，为了简单起见，学习到的mask只对应于body part的三个部位：head、upper body、lower body。  </p><p>因此，我们想要 edit 的图像前景 region 可以被表示为，$ p^a = x^a \bigodot m^a $，（比如，行人的上半身）；同理，我们不感兴趣的其他region可以被表示为，$q^a = x^a \bigodot (1-m^a)$，也就是背景区域。$\bigodot$代表跨通道的按元素相乘。</p><p><strong>小结</strong>：我们通过上述处理流程得到了行人图像集合 $X^A$ ，并且分别得到了编辑regions和背景regions 集合 $P^A = X^A \bigodot M^A$、$Q^A = X^A \bigodot (1-M^A)$</p><h2><span id="2-the-generator">2 The Generator</span><a href="#2-the-generator" class="header-anchor">#</a></h2><h3><span id="2-1-encoder-decoder-network-with-skip-connection">2.1 Encoder-decoder network with skip connection</span><a href="#2-1-encoder-decoder-network-with-skip-connection" class="header-anchor">#</a></h3><p><img src="/2020/04/16/apie/b.png" alt="generator" style="zoom:67%;"></p><p>该网络包含一个<strong>encoder和一个decoder</strong>，分别表示为$G_{enc}$ 和 $G_{dec}$。</p><p>① encoder $ G_{enc} $ 使用几个卷积层，输入我们在上一步挑选出来的感兴趣的 region $ p^a $，输出 latent variable $z^a$。</p><p>② 然后我们在 attribute vector $a$中随机反转一位，来得到新的 attribute vector $b$，同时检查是否发生了属性冲突，比如行人同时穿了蓝色和红色的衣服。</p><p>③ 然后将 $ b $ 和 latent variable $ z^a $ 联结起来，一起传入decoder $ G_{dec} $ 的 deconvolution层，这样我们就生成了新的感兴趣 region 图像 $p^b$。同理，我们将 $ a $ 和 latent variable $ z^a $ 联结起来，传入decoder $ G_{dec} $ 的 deconvolution层，我们可以得到重建的原始感兴趣region的图像 ${p^a}^\sim$，$\sim$ 区分了这是重建后的interest region，而不是original的interest region。</p><p><strong>注意</strong>：在对应的 convolution层和 deconvolution层之间采用skip connection，使得 Encoder-decoder network 变成 U-net。</p><p><strong>小结</strong>：</p><p>上述过程公式化如下</p><p>$Z^A = G_{enc}(P^A)$，${p^A}^\sim = G_{dec}(Z^A,A)$，$P^B = G_{dec}(Z^A,B)$。</p><p>因为重建的interest region应该尽可能和接近original的interest region，所以我们 <strong>Encoder-decoder network的loss 函数</strong>如下：</p><p>$L_{rec} = {\mid\mid P^A - {p^A}^\sim \mid\mid}^2$</p><h3><span id="2-2-discrimination-between-latent-variables">2.2 Discrimination between latent variables</span><a href="#2-2-discrimination-between-latent-variables" class="header-anchor">#</a></h3><p>因为行人图像的一些属性是纠缠在一起的，甚至一些属性可能是互斥的。eg：行人的性别和他的服饰高度相关，而蓝色上衣和白色上衣就是互斥的。因此，我们如果想要根据属性 $b$ 来 edit 图像，我们必须要关注属性的共存和互斥。</p><p>显然，我们单纯靠手动屏蔽 $b$ 中的属性，以避免和 latent variable $ z^a $ 的冲突是不现实的，一个更好的方法是在encoding的过程中<strong>自动从latent variable 中擦去属性</strong>。因此，我们选用了针对 latent variable 的对抗学习，详细来说，我们生成的 interest region $p_b$ 被重新输入到 encoder 中去，以获得新的 latent variable $z^b$ 。</p><p>然后，一个<strong>鉴别器</strong> $D_z$ 被训练来区分 latent variable  $ z^a $ 和 $z^b$ ，公式为：</p><p><img src="/2020/04/16/apie/e.png" alt="e" style="zoom: 50%;"></p><p><strong>对抗的min-max过程为</strong>：</p><script type="math/tex; mode=display">\min_{G_{enc}} \max_{\mid\mid D_Z \mid\mid \leq 1} L_{adv_{D_z}}</script><p><strong>个人理解</strong>就是 encoder 的目标是最小化两个 latent variable 的差别，最优的情况肯定就是两个 latent variable 完全一样，完全一样就证明了我们的属性信息被完全擦除了，这样我们在选择 attribute vector $a$ 中反转哪一个属性时，就不需要在乎会不会和 latent variable 中携带的属性冲突，我们选择什么样的 $b$ 都可以了！也就是说，当 latent variable 满足这种不变性时，decoder 要是想要生成图像，就必须使用我们的 attribute vector ，因为latent variable 中是几乎不携带属性的，这就完成了隐式的属性擦除！</p><h2><span id="3-the-multi-scale-discriminators">3 The Multi-scale Discriminators</span><a href="#3-the-multi-scale-discriminators" class="header-anchor">#</a></h2><p><img src="/2020/04/16/apie/c.png" alt="c"></p><p>我们使用使用另一个对抗学习过程来保证生成图像 $X_B=P_B+Q_A$ 的真实性（注：$X_B$ 和 $X_A$ 具有一样的大小），为了捕捉丰富的局部视觉细节，我们采用了<strong>两个不同 resolution 的 discriminator判别器</strong>，如上图所示。</p><p>判别器 $D_1$ 依然是把之前生成的图像作为输入。</p><p>判别器  $D_2$ 输入的是对生成图像经过下采样，得到的只有一半 resolution 的图像。</p><p>因为原始GAN模型不稳定的训练过程，这里作者选取了 <strong>WGAN-GP</strong> 模型，<strong>鉴别器的公式如下</strong>：</p><p><img src="/2020/04/16/apie/d.png" alt="d" style="zoom:67%;"></p><p><strong>Multi-scale discriminators 的总体损失</strong>是：</p><script type="math/tex; mode=display">L_{adv} = L_{adv1} + L_{adv2}</script><p><strong>对抗过程的优化目标</strong>是：</p><script type="math/tex; mode=display">\min_{G} \max_{\mid\mid D_* \mid\mid \leq 1} L_{adv}</script><p>注：</p><script type="math/tex; mode=display">D_* (X^B)=D_* (G_{dec}(G_{enc}(X^A \bigodot M^A),B)+X^A \bigodot (1-M^A))</script><p>并且 $G$ 表示解码器和编码器中的参数</p><h2><span id="4-the-attribute-classifier">4 The Attribute Classifier</span><a href="#4-the-attribute-classifier" class="header-anchor">#</a></h2><p>通过之前的介绍，我们可以知道 <strong>APIE-Net 是根据传递属性来 edit 行人图像的</strong>，即更改一个属性，保持其他属性不变。所以<strong>评估模型能力</strong>的办法就是就是去调查<strong>生成图像的属性</strong>。</p><p>为此，我们构建了一个分类器，Attribute Classifier 这个分类器将生成图像 $x_b$ 作为输入，将估计的 attribute vector $b^{\sim}$ 作为输出，然后通过交叉熵损失函数来比较真实的 attribute vector $b$  和 估计得到的 $b^{\sim}$ 。</p><script type="math/tex; mode=display">L_{cls} = \sum_{b^{\sim} \in B^{\sim},b \in B} -blogb^{\sim}-(1-b)log(1-b^{\sim})</script><p>注：值得注意的地方是因为我们的 classifier 和multi-scale discriminators 中的 $D_1$ 其实都用到了根据生成图像以提取attribute vector，所以他们是共享参数的。所以，我们的 attribute classification 和 image discrimination 是相互影响的。</p><h2><span id="5-the-overall-loss">5 The Overall Loss</span><a href="#5-the-overall-loss" class="header-anchor">#</a></h2><p>generator、multi-scale discriminators、attribute classifier同时被训练，他们优化的<strong>整体损失函数为</strong>：</p><script type="math/tex; mode=display">L(C,G_{enc},G_{dec},D_1,D_2,D_Z)=L_{adv}+\lambda_C L_{cls}+\lambda_R L_{rec}+\lambda_{D_Z} L_{adv_{D_z}}</script><p>$\lambda_*$ 是用来平衡损失的超参数。之前计算过的 $L$ 如下，</p><script type="math/tex; mode=display">L_{rec} = {\mid\mid P^A - {p^A}^\sim \mid\mid}^2</script><p><img src="/2020/04/16/apie/e.png" alt="e" style="zoom: 50%;"></p><script type="math/tex; mode=display">L_{adv} = L_{adv1} + L_{adv2}</script><script type="math/tex; mode=display">L_{cls} = \sum_{b^{\sim} \in B^{\sim},b \in B} -blogb^{\sim}-(1-b)log(1-b^{\sim})</script><p>在对抗性训练过程之后，<strong>参数可以通过以下min-max 博弈获得</strong>：</p><p><img src="/2020/04/16/apie/f.png" alt="f" style="zoom: 67%;"></p><h1><span id="shi-yan">实验</span><a href="#shi-yan" class="header-anchor">#</a></h1><h2><span id="3-1-datasets-and-implementation">3.1  Datasets and implementation</span><a href="#3-1-datasets-and-implementation" class="header-anchor">#</a></h2><p> Dataset： Market-1501和 DukeMTMC-reID , with labels</p><p>三个实验：① pedestrian images generation ② person re-ID ③ attribute learning</p><h2><span id="3-2-pedestrian-image-editing">3.2 Pedestrian Image Editing</span><a href="#3-2-pedestrian-image-editing" class="header-anchor">#</a></h2><p><img src="/2020/04/16/apie/res1.png" alt="res1" style="zoom:67%;"></p><p>与其他4个常用的 image edit 方法对比，在面部属性编辑方面表现良好，但在行人编辑场景中表现不佳</p><p><img src="/2020/04/16/apie/res2.png" alt="res2" style="zoom:67%;"></p><p> <strong>定量比较的结果</strong>，根据Inception score (IS) </p><p><img src="/2020/04/16/apie/res3.png" alt="res3" style="zoom: 50%;"></p><h2><span id="3-3-person-re-id-and-attribute-prediction-de-shu-ju-zeng-qiang">3.3  Person Re-ID and Attribute Prediction 的数据增强</span><a href="#3-3-person-re-id-and-attribute-prediction-de-shu-ju-zeng-qiang" class="header-anchor">#</a></h2><p><img src="/2020/04/16/apie/res4.png" alt="res4" style="zoom: 50%;"></p><h2><span id="3-4-ablation-study">3.4  Ablation Study</span><a href="#3-4-ablation-study" class="header-anchor">#</a></h2><p>最后为了验证各模型部件对最终模型性能的有效性，还做了Ablation Study，结果证明，最终的组合比每个单独的部分表现得更好。（nice）</p><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h1><p>这篇文章提出的 Attribute-aware Pedestrian Image Editing 方法，通过指定的属性，可以生成较高质量的行人图像，以扩充现有行人图像数据集，综合实验也证明其有效性。</p><h1><span id="wo-de-si-kao">我的思考</span><a href="#wo-de-si-kao" class="header-anchor">#</a></h1><ol><li>attribute-aware pedestrian segmentation中提到，学习到的mask只对应于body part的三个部位，可以改进的地方是需要更加细粒度的转变，现在还仅仅停留在较大粒度的行人图像编辑；</li><li>行人图像编辑，如果针对不完整的行人图像，比如有某部分被覆盖住了，不知道此论文中的方法是否有效？我有看过一篇在CVPR2020中发布的有关自监督去遮挡的文章 Self-Supervised Scene De-occlusion ，感觉可以先去遮挡，再使用本文方法，这样可以扩大可以编辑图像的范围。</li><li>好像文中的方法，仅可以一次更改一个属性，是否可以同时更改多个属性呢？</li></ol>]]></content>
      
      
      <categories>
          
          <category> paper-cv </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>how to use markdown</title>
      <link href="2020/04/13/markdown/"/>
      <url>2020/04/13/markdown/</url>
      
        <content type="html"><![CDATA[<h2><span id="1-biao-ti">1 标题</span><a href="#1-biao-ti" class="header-anchor">#</a></h2><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><span id="more"></span><h2><span id="2-duan-luo">2 段落</span><a href="#2-duan-luo" class="header-anchor">#</a></h2><blockquote><p>段落的换行是使用<strong>两个以上空格加上回车</strong>，也可以在段落后面使用一个空行来表示重新开始一个段落</p></blockquote><p><strong>字体</strong>：</p><pre><code>*斜体文本***粗体文本*****粗斜体文本***</code></pre><p><strong>分割线</strong></p><blockquote><p>在一行中用三个以上的星号建立一个分隔线</p></blockquote><pre><code>***</code></pre><p><strong>删除线</strong></p><p><del>在两端加上两个波浪线</del></p><pre><code>~~Baidu~~</code></pre><p><strong>下划线</strong></p><pre><code>&lt;u&gt;带下划线的文本&lt;/u&gt;</code></pre><p><strong>脚注</strong></p><pre><code>创建脚注格式类似这样 [^RUNOOB]。[^RUNOOB]:菜鸟教程 -- 学的不仅是技术，更是梦想！！！</code></pre><p>我是一个脚注  <sup><a href="#fn_myself" id="reffn_myself">myself</a></sup> 。</p><h2><span id="3-lie-biao">3 列表</span><a href="#3-lie-biao" class="header-anchor">#</a></h2><p><strong>无序列表</strong></p><pre><code>- 第一项- 第二项- 第三项</code></pre><p><strong>有序列表</strong></p><pre><code>1. 第一项2. 第二项3. 第三项</code></pre><p><strong>列表嵌套</strong></p><blockquote><p>只需在子列表中的选项添加四个空格即可</p></blockquote><pre><code>1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素</code></pre><h2><span id="4-qu-kuai">4 区块</span><a href="#4-qu-kuai" class="header-anchor">#</a></h2><blockquote><p>在段落开头使用 &gt; 符号 ，然后后面紧跟一个<strong>空格</strong>符号：</p></blockquote><pre><code>区块嵌套&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套区块中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项&gt; + 第三项列表中使用区块：需要在 &gt; 前添加四个空格的缩进* 第一项    &gt; oneone    &gt; twotwo* 第二项</code></pre><ul><li>第一项<blockquote><p>oneone<br>twotwo</p></blockquote></li></ul><h2><span id="5-dai-ma">5 代码</span><a href="#5-dai-ma" class="header-anchor">#</a></h2><blockquote><p>用 ``` 包裹一段代码，并指定一种语言（也可以不指定）</p></blockquote><h2><span id="6-lian-jie">6 链接</span><a href="#6-lian-jie" class="header-anchor">#</a></h2><pre><code>这是一个链接 [链接名](https://www.baidu.com)直接使用链接地址&lt;https://www.baidu.com&gt;可以通过变量来设置一个链接，变量赋值在文档末尾进行：这个链接用 1 作为网址变量 [Google][1]这个链接用 runoob 作为网址变量 [Runoob][runoob]然后在文档的结尾为变量赋值（网址）[1]: http://www.google.com/[runoob]: http://www.runoob.com/</code></pre><p>这是一个链接 <a href="https://www.baidu.com">链接名</a></p><h2><span id="7-tu-pian">7 图片</span><a href="#7-tu-pian" class="header-anchor">#</a></h2><pre><code>开头一个感叹号 !;接着一个方括号，里面放上图片的替代文字;接着一个普通括号，里面放上图片的网址![alt 属性文本](图片地址)Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。&lt;img src="xxxx.png" width="50%"&gt;</code></pre><h2><span id="8-biao-ge">8 表格</span><a href="#8-biao-ge" class="header-anchor">#</a></h2><blockquote><p>使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行<br>并且可以设置表格的对齐方式</p></blockquote><pre><code>| 表头 | 表头 || --- | --- || 单元格 | 单元格 || 单元格 | 单元格 |-: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |</code></pre><h2><span id="9-html">9 HTML</span><a href="#9-html" class="header-anchor">#</a></h2><blockquote><p>Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写<br>持的 HTML 元素有：<kbd> <b> <i> <em> <sup> <sub> <br>等 ，如：</sub></sup></em></i></b></kbd></p></blockquote><pre><code>使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑</code></pre><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p><h2><span id="10-gong-shi">10 公式</span><a href="#10-gong-shi" class="header-anchor">#</a></h2><blockquote><p>使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现</p></blockquote><pre><code>$$\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix} \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \\\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \\\end{vmatrix}${$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}$$</code></pre><script type="math/tex; mode=display">\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix} \mathbf{i} & \mathbf{j} & \mathbf{k} \\\frac{\partial X}{\partial u} &  \frac{\partial Y}{\partial u} & 0 \\\frac{\partial X}{\partial v} &  \frac{\partial Y}{\partial v} & 0 \\\end{vmatrix}${$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}</script><h2><span id="11-liu-cheng-tu">11 流程图</span><a href="#11-liu-cheng-tu" class="header-anchor">#</a></h2><pre><code>横向流程图 + mermaidgraph LRA[方形] --&gt; B(圆角)B--&gt; C{条件a}C--&gt;|a=1| D[结果1]C--&gt;|a=2| E[结果2]F[横向流程图]</code></pre><pre class=" language-lang-mermaid"><code class="language-lang-mermaid">graph LRA[方形] --> B(圆角)B--> C{条件a}C-->|a=1| D[结果1]C-->|a=2| E[结果2]F[横向流程图]</code></pre><pre><code>竖向流程图graph TDA[方形] --&gt; B(圆角)B --&gt; C{条件a}C --&gt; |a=1| D[结果1]C --&gt; |a=2| E[结果2]F[竖向流程图]</code></pre><pre class=" language-lang-mermaid"><code class="language-lang-mermaid">graph TDA[方形] --> B(圆角)    B --> C{条件a}    C --> |a=1| D[结果1]    C --> |a=2| E[结果2]    F[竖向流程图]</code></pre>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>The Website</title>
      <link href="2020/04/13/about-me/"/>
      <url>2020/04/13/about-me/</url>
      
        <content type="html"><![CDATA[<h1><span id="jie-shao">介绍</span><a href="#jie-shao" class="header-anchor">#</a></h1><p>本网站用途：</p><ol><li>随时记录一些个人的学习总结；</li><li>记录一些关于日常生活的感悟；</li><li>其他一些杂七杂八的东西；</li></ol>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
